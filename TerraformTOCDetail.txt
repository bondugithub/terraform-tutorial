Day 1


References:
https://learn.hashicorp.com/tutorials/
https://www.terraform.io/
https://github.com/stacksimplify/hashicorp-certified-terraform-associate-on-azure
------------------------------------------------------------------------------------------------------
Introduction
------------------------------------------------------------------------------------------------------
	1. Install terraform
		https://learn.hashicorp.com/tutorials/terraform/install-cli
	2. Install azure cli
		https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-linux?pivots=script
		Instead of 
			sudo dnf install azure-cli
			sudo yum install azure-cli
	3. Configure azure
	
	Step-05: Terraform - Authenticating using the Azure CLI
		Azure Provider: Authenticating using the Azure CLI
		# Azure CLI Login
		az login

		# List Subscriptions
		az account list

		# Set Specific Subscription (if we have multiple subscriptions)
		az account set --subscription="SUBSCRIPTION_ID"	
	
	-------------------
Infrastructure as Code (IaC) 
	Process of managing and provisioning the complete IT infrastructure 
	(comprises both physical and virtual machines) 
		using machine-readable definition files. 
	Automate environment provisioning process.
	Ease maintenance of the environment.
	Manage the source code of it in SCM.


Challenges with Infrastructure as Code :
	Need to learn to code
	Don’t know the change impact.
	Need to revert the change
	Can’t track changes
	Can’t automate a resource
	Multiple environments for infrastructure
	Terraform has been created to solve these challenges.


Terraform introduction	
----------------------
What is Terraform?
	Open-source infrastructure as Code 
	Developed by HashiCorp. 
	Used to define and provision the complete infrastructure 
	Declarative language.

	Infrastructure provisioning tool 
	Cloud infrastructure setup as codes. 
	Similar to tools like CloudFormation
		However provider independent.
	
	
Adv. of Terraform
	Does orchestration, not just configuration management
	Supports multiple providers such as AWS, Azure, GCP, DigitalOcean and many more
	Provide immutable infrastructure where configuration changes smoothly
	Uses easy to understand language, HCL (HashiCorp configuration language)
	Easily portable to any other provider
	Supports Client only architecture, so no need for additional configuration management on a server


References: D:\PraiseTheLord\HSBGInfotech\DevOps\Terraform\TerraformTOC.txt

The Core Terraform Workflow
The core Terraform workflow has three steps:
    Write - Author infrastructure as code.
    Plan - Preview changes before applying.
    Apply - Provision reproducible infrastructure.

Vilas: Copied from my notes
------------------------------------------------------------------------------------------------------

https://www.terraform.io/language
Terraform Language
	main purpose 
		declare resources
			represent infrastructure objects. 
	
	All other language features 
		make the definition of resources more flexible and convenient.

A Terraform configuration 
	complete document in Terraform language 
	Tells Terraform 
		how to manage a given collection of infrastructure. 
	Can consist of multiple files and directories.

Syntax of the Terraform language 
	simple

resource "aws_vpc" "main" {
  cidr_block = var.base_cidr_block
}

<BLOCK TYPE> "<BLOCK LABEL>" "<BLOCK LABEL>" {
  # Block body
  <IDENTIFIER> = <EXPRESSION> # Argument
}
e.g. 
resource "azurerm_resource_group" "myrg" { # Resource BLOCK
  name = "myrg-1" # Argument
  location = "East US" # Argument 
}

Blocks 
------
	Most of Terraform's features 
		controlled by top-level blocks in a configuration file.
		
	containers for other content 
	represent configuration of an object
		e.g. resource. 
	have a block type
	
	can have 
		zero or more labels
	a body 
		contains (number of) arguments 
		nested blocks. 
	



Arguments 
---------
	assign a value to a name. 
	They appear within blocks.
	can be 
		required or 
		optional
	Meta-Arguments 
		change a resource type's behavior 
			e.g.: 
				count, 
				for_each


Expressions 
-----------
	represent a value
	either 
		literally or 
		by referencing and combining other values. 
	Appear as values for arguments, or within other expressions.
	format:
		resource_type.resource_name.attribute_name
	 
The Terraform language 
----------------------
	declarative
		Describing an intended goal 
		Not steps to reach that goal. 
	The ordering of 
		blocks and 
		files 
			not significant; 
			
	Considers 
		implicit and 
		explicit relationships 
			between resources when determining an order of operations.

Files and Directories
---------------------
	Files containing Terraform 
		called configuration files.

	Configuration (Module) Directory
	-----------------------
		Directory 
			can have any number of configuration files.
		Any file with .tf extension 
			will participate in CRUD of the infrastructure components.
		One file 
			any number of configuraiton blocks.
		
		Common other files found
			main.tf - main configuration
			variables.tf - variables delclaration
			outputs.tf - outputs from resources.
			providers.tf - define providers
			
				can be .tf.json also - but commonly used.
		
	File Extension
	--------------
		Code in Terraform language 
			Stored in simple text files 
			.tf file extension. 
			or JSON-based variant - .tf.json file extension.

	Text Encoding
	-------------
		Configuration files must always use UTF-8 encoding, and by convention usually use Unix-style line endings (LF) rather than Windows-style line endings (CRLF), though both are accepted.

	Directories and Modules
	-----------------------
		
		A module 
			collection of .tf and/or .tf.json files 
			kept together in a directory.
		
		Similar to function definitions in traditional languages
		
		A Terraform module 
			consists of the top-level configuration files in a directory; 
			nested directories 
				treated as completely separate modules
				not automatically included in the configuration.

		Terraform evaluates 
			all configuration files in a module
			treat the entire module as a single document. 
		Separating blocks into different files 
			purely for the convenience 
			no effect on the module's behavior.

	A Terraform module 
		can use module calls 
		explicitly include other modules into the configuration. 
		Child modules can come from 
			nested directories, or 
			anywhere else on disk or 
			external sources 
				e.g. Terraform Registry.

The Root Module
---------------
	Terraform 
		always runs in the context of a single root module. 
		A complete Terraform configuration 
			has a root module 
			tree of child modules 
			(modules called by the root module
			modules called by those modules, etc.).

	root module 
		working directory where Terraform command is invoked. 



Hands-on
	different ways to configure terraform with azure
	
		Configure Terraform in 
			Azure Cloud Shell 
				with Bash
					https://docs.microsoft.com/en-us/azure/developer/terraform/get-started-cloud-shell-bash
				with PowerShell
					https://docs.microsoft.com/en-us/azure/developer/terraform/get-started-cloud-shell-powershell
			Windows 
				with Bash
					https://docs.microsoft.com/en-us/azure/developer/terraform/get-started-windows-bash
				with PowerShell
					https://docs.microsoft.com/en-us/azure/developer/terraform/get-started-windows-powershell
			Azure with Terraform on linux_amd64
				https://github.com/vilasvarghese/terraform-tutorial/blob/master/azure/GettingStarted.txt
				Configure Azure
					configure storage 
				Install Terraform 
					https://github.com/vilasvarghese/terraform-tutorial/blob/master/1d_Linux_install/terrafrom.sh
				Install azure cli
					azure login
					az account list
					az account set --subscription="95cbd6d2-947f-4cf1-bba7-5f90bc47dc43"

------------------------------------------------------------------------------------------------------
Terraform Setting and Provider Block
------------------------------------------------------------------------------------------------------
	Step-01: Terraform Settings Block Introduction
	------------------------------------------------------------------------------------------------------
	Terraform Settings
	------------------
		A special terraform configuration block 
		Used to configure 
			of Terraform itself
			e.g. minimum Terraform version to apply your configuration.

		Terraform Block Syntax
		terraform {
		  # ...
		}
		
		Each terraform block 
			can contain a number of settings 
			only constant values permitted
			
		Options supported in terraform block .
			Configuring Terraform Cloud
				https://www.terraform.io/language/settings
			Configuring a Terraform Backend
				For Remote State Storage
				https://www.terraform.io/language/settings
			Specifying a Required Terraform Version
			Specifying Provider Requirements
			Experimental Language Features
				https://www.terraform.io/language/settings
			Passing Metadata to Providers
				https://www.terraform.io/language/settings
				provider_meta block 
					for each provider a module 
				if the provider defines a schema for it. 
					This allows the provider to receive module-specific information
					primarily intended for modules distributed 
					by the same vendor as the associated provider.
	
	------------------------------------------------------------------------------------------------------
	Step-02: Understand required_version in Terraform Block
	------------------------------------------------------------------------------------------------------
		
		Hands-on: 
			Manage Terraform Versions 
			required_version setting 
				accepts a version constraint string
				If the running version of Terraform 
					doesn't match the constraints 
					Terraform give error 
					exit without taking any further actions.

		For child modules, 
			each module can specify its own version requirements. 
			The requirements of all modules in the tree must be satisfied.

		Use Terraform version constraints 
			in a collaborative environment to ensure that everyone 
			is using a specific Terraform version, 
			or using at least a minimum Terraform version 
			that has behavior expected by the configuration.

		different from provider version

terraform {
  required_providers {
    aws = {
      version = "~> 2.13.0"
    }
    random = {
      version = ">= 2.1.2"
    }
  }
  required_version = "~> 0.12.29"

}	


		required_version 
			applies only Terraform CLI version. 
		Terraform's resource types 
			implemented by provider plugins, 
			release cycles are independent 
				of Terraform CLI and 
				of each other. 
		Use required_providers block 
			to manage the expected versions for each provider you use.
		

	------------------------------------------------------------------------------------------------------
	Step-03: Terraform Provider Introduction
	------------------------------------------------------------------------------------------------------
		The required_providers block 
			specify all of the providers 
				required by the current module
			map each local provider name 
				to 
					a source address and 
					a version constraint.
	For aws
		terraform {
		  required_providers {
			aws = {
			  version = ">= 2.7.0"
			  source = "hashicorp/aws"
			}
		  }
		}
		
	For azure	
		terraform {
		  required_providers {
			azurerm = {
			  source  = "hashicorp/azurerm"
			  version = "=3.0.0"
			}
		  }
		}

	For multiple providers
		terraform {
		  required_providers {
			aws = {
			  version = "~> 2.13.0"
			}
			random = {
			  version = ">= 2.1.2"
			  #source is not mandatory
			}
		  }

		  required_version = "~> 0.12.29"
		}	

		Reference: steps/1/
		terraform init
		change version=">=3.0.0" 
						"=3.0.0"
		terraform init
	------------------------------------------------------------------------------------------------------
	Step-04: Understand required_providers in Terraform Block and Provider Block
	------------------------------------------------------------------------------------------------------
	Provider Requirements

	Terraform relies on plugins called "providers" 
		to interact with remote systems. 
		Terraform configurations must declare 
			which providers they require
		Terraform will install and use them. 

N.B:
	Values in 
		[] 
			called list
		{}
			caleld Map


	Note: 
		Supported from Terraform 0.13 and later; 
		A provider requirement consists of 
			local name (mycloud below)
			a source location, and 
			a version constraint:

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}

	key: mycloud
		provider's local name 
		unique identifier 
			unique per-module
			module-specific
		value is an object 
			source - 
				the global source address 
				e.g. hashicorp/aws.
			version - 
				a version constraint 
		can choose any local name 
		has a preferred local name (e.g. aws)
		uses as a prefix for all of its resource types.
		hashicorp/aws - aws, like aws_instance or aws_security_group.)

		If possible
			use a provider's preferred local name. 
			make configurations easier to understand, 
				omit the provider meta-argument 
					from most of your resources. 
			(If provider is NOT configured, 
				first word of the resource type 
					as a local provider name.)


	Note: The name = { source, version } syntax
		added in Terraform v0.13. 
		
	Outside of the required_providers block, 
		Terraform configurations refer to providers by their local names.

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
    }
  }
}

provider "mycloud" {
  # ...
}

----------------------
lab/2

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}

# Configure the Microsoft Azure Provider
provider "azurerm" {
  features {}
}

# Create a resource group
resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}
----------------------

Source Addresses
----------------

A provider's source address 
	global identifier. 
	primary location to download.
	three parts 
		delimited by slashes (/), as follows:
		[<HOSTNAME>/]<NAMESPACE>/<TYPE>

    Hostname (optional): 
		hostname of the Terraform registry 
			distributes the provider. 
		default:
			registry.terraform.io
			public Terraform Registry.
    Namespace (mandatory): 
		organizational namespace 
			in registry
		In 
			public Terraform Registry and 
			Terraform Cloud's private registry, 
				organization that publishes the provider. 
    Type(mandatory): 
		A short name for 
			platform provider manages. 
		Must be unique in 
			namespace on a particular registry host.
		provider's preferred local name. 
		(Exceptions; 
			hashicorp/google-beta 
				alternate to hashicorp/google
				preferred local name is google. 
		)

	official HTTP provider 
		part of hashicorp namespace 
		on registry.terraform.io
		source address 
			registry.terraform.io/hashicorp/http or, 
			commonly: hashicorp/http.

	The source address 
		with all three components 
			called the provider's fully-qualified address. 
	can be seen in various outputs
		e.g. error messages
		in most cases a simplified display version is used. 
	
	Display version 
		omits the source host 
		for public registry, 
		so "hashicorp/random" 
			instead of "registry.terraform.io/hashicorp/random".

	Note: 
		If you omit the source argument for provider, 
		default registry.terraform.io/hashicorp/<LOCAL NAME>. 
		recommend: using explicit source addresses for all providers.

Version Constraints
	Each provider plugin 
		has set of versions
		functionality of the provider 
			can evolve over time. 
		Each provider 
			define version constraint 
			given in the version argument 
		so Terraform can select a single version per provider 
		that all modules are compatible with.

	The version argument is optional; 
		if omitted, 
		accept any version of the provider as compatible. 
		recommend 
			specify a version constraint.

	To ensure Terraform always installs the same provider versions 
		for a given configuration, 
		use Terraform CLI 
			to create a dependency lock file and 
			commit it to version control 
	If a lock file is present, 
		Terraform Cloud, 
		CLI, and 
		Enterprise 
			will all obey it when installing providers.

lab: 
			Try the Lock and Upgrade Provider Versions.

Best Practices for Provider Versions
	declare the minimum provider version 
		use >= version constraint syntax:

terraform {
  required_providers {
    mycloud = {
      source  = "hashicorp/aws"
      version = ">= 1.0"
    }
  }
}

root module of a configuration — 
	specify the maximum provider version 
	avoid accidental upgrades 
	to incompatible new versions. 
	~> operator  
	The following example 

terraform {
  required_providers {
    mycloud = {
      source  = "hashicorp/aws"
      version = "~> 1.0.4"
    }
  }
}
Recommendation:
Child modules can define minimum version 
	root module manage the maximum version.



Built-in Providers
------------------
Most Terraform providers 
	distributed as plugins

one built in provider  
	provides the terraform_remote_state data source.
don't need to declare 
	available to define in required_providers block 
For consistency 
	has special provider source address, 
	terraform.io/builtin/terraform. 
	sometimes appear in Terraform's error messages 

Deprecated provider
-------------------
	Another provider with source address 
		hashicorp/terraform
		older version of the now-built-in provider 
		not compatible with Terraform v0.11 or later 
		should never be declared in a required_providers block.


In-house Providers
------------------
We can 
	develop and distribute 
	Terraform providers. 



run an in-house private registry
	implement provider registry protocol.
Providers 
	mandatory: 
		source address 
		hostname of a registry
		hostname does not need to provide an actual registry service. 
		in-house providers  
			use an arbitrary hostname 
			
terraform {
  required_providers {
    mycloud = {
      source  = "terraform.example.com/examplecorp/ourcloud"
      version = ">= 1.0"
    }
  }
}

address: terraform.example.com/examplecorp/ourcloud/1.0.0

Directory structure
In 1.0.0 directory
	an additional directory 
		platform, 
		e.g. linux_amd64 - AMD64/x64 processor, and 
	

v0.12-Compatible Provider Requirements
--------------------------------------

    Provider type names 
		always be written in lowercase. 
		Terraform v0.13 
			provider source address: 
				case-insensitive
	

This tutorial is covered based on Terraform v0.13 and above.	
	------------------------------------------------------------------------------------------------------	
	Step-05: Terraform Apply and Destroy Commands Auto Approve Option
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/cli/commands/apply
	Command: apply
	
	terraform apply
	terraform apply -auto-approve
	terraform destroy
	To delete a particular resource
	terraform destroy -target RESOURCE_TYPE.NAME
	terraform destroy -auto-approve

	The terraform apply 
		execute the actions proposed in a Terraform plan.



	run terraform apply 
		without plan file
		creates a new execution plan = terraform plan
		prompts to approve 
		takes the indicated actions. 
		
		
		
Warning: If you use -auto-approve, 
	recommend 
		no one can change outside Terraform workflow. 
		
Saved Plan Mode
---------------
	pass a saved plan file to terraform apply, 
	no confirmation required. 
	use in automation.


	step2/
	terraform plan -out tfplan
	terraform show tfplan #inspect saved plan
	terraform apply "tfplan"

When using a saved plan
	additional planning modes not supported 
	
	
Plan Options
------------

    Planning Modes: 
		include 
			terraform plan -destroy
				creates a plan to destroy all remote objects
			terraform plan -refresh-only
				creates a plan to update 
					Terraform state 
					root module output values.
    Planning Options: 
		specify which 
			resource instances Terraform should replace
		setting Terraform input variables, etc.

Apply Options
-------------
    -auto-approve 
		Skips interactive approval 
		option is ignored 
			when you pass a previously-saved plan file, 
    -compact-warnings
    -input=false 
		- Disables all of Terraform's interactive prompts. 
		- prevents prompting for interactive approval of a plan
    -json - 
		machine readable JSON UI output. 
		implies -input=false.
    -lock=false - 
		Don't hold a state lock during the operation. 
			dangerous 
			others might concurrently run commands.
    -lock-timeout=DURATION - 
		Unless locking is disabled with -lock=false, 
		Terraform should retry acquiring a lock 
			return an error. 
		-lock-timeout="3s" for three seconds.
    -no-color - Disables terminal formatting sequences in the output
    -parallelism=n - 
		Limit the number of concurrent operation as Terraform walks the graph. 
		Defaults to 10.

    All planning modes and planning options for terraform plan - Customize how Terraform will create the plan. Only available when you run terraform apply without a saved plan file.


For configurations using the local backend only, terraform apply also accepts the legacy options -state, -state-out, and -backup.



Command: destroy
	destroy all remote objects 
		managed by a particular Terraform configuration.


Usage
Usage: terraform destroy [options]

This command is just a convenience alias for the following command:
terraform apply -destroy

So this command accepts 
	most of the options that terraform apply 
	does not accept a plan file argument 
	
	
terraform plan -destroy
terraform destroy -auto-approve 

Note: The -destroy option to terraform apply 
	exists only in Terraform v0.15.2 and later. 
		use terraform destroy .


	-auto-approve is not mentioned in documentation for destroy. 
	But will work.
	




https://learn.hashicorp.com/tutorials/terraform/apply?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS
Apply configuration
-------------------
Steps terraform takes.
	1. Lock your project's state
			so other instances of Terraform 
				will not attempt to 
				modify state or 
					apply changes to your resources. 
	2. If Terraform detects an existing lock file 
		(.terraform.tfstate.lock.info), 
		report an error and exit.
	3. Execute steps according to the plan.
		Terraform 
			executes in parallel 
			when possible, 
		and sequentially 
			when one resource 
				depends on another.
	4. Update your project's state file 
		with a snapshot of the current state 
	5. Unlock the state file.
	6. Print out 
		(a) report of the changes it made
		(b) any output values defined 
		
Errors during apply
-------------------
If apply has errors
	Logs the error and reports it to the console.
	Updates the state file with any changes to your resources.
	Unlocks the state file.
	Exits.
Terraform does not support 
	rolling back a partially-completed apply. 
	infrastructure may be in an invalid state 
		after a Terraform apply step errors out. 
	So resolve error, 
		apply configuration again 
			to update your infrastructure to the desired state.



Common reasons for apply:
--------------------------------------
	A change to a resource outside of Terraform's control.
		while execution is going on someone deletes RG.
	Networking or other transient errors.
	An expected error from the upstream API, 
		e.g. duplicate resource name or reaching a resource limit.
	An unexpected error from the upstream API
		e.g. internal server error.
	A bug in 
		Terraform provider code
		Terraform itself.
		our configuration

------------------------------------------------------------------------------------------------------	
Terraform Multiple Provider
------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-01: Terraform Multiple Providers Introduction
	------------------------------------------------------------------------------------------------------
	Provider Configuration
	----------------------
	Providers 
		allow Terraform to interact with 
			cloud providers
			SaaS providers, and 
			other APIs.

	Some providers require  
		configure 
			endpoint URLs, 
			cloud regions
			other settings 
				before Terraform can use them. 
	
	
	Provider Configuration
	----------------------
	Provider configurations 
		belong in the root module of a Terraform configuration. 
	A provider configuration 
		use a provider block:

provider "google" {
  project = "acme-app"
  region  = "us-central1"
}

	Provider block is optional
	name ("google") 
		local name of the provider to configure. 
		provider should be included in 
			required_providers block.
	block (between { and }) contains 
		configuration arguments for the provider. 
		most options
			defined by the provider 
			project and region are specific to the google provider.
		values 
			supported values.
			reference input variables
			not attributes exported by resources 
		provider's documentation 
			should list which configuration arguments it expects. 
	Some values
		use shell environment variables 
			(e.g. VM instance profiles) 
		recommend 
			use for credentials 
				out of your version-controlled Terraform code.
	two "meta-arguments" 
		defined by Terraform itself 
		available for all provider blocks:
			alias:
				use same provider with different configurations for different resources
			version: 
				not recommended 
					(use provider requirements instead)
	
alias: Multiple Provider Configurations
---------------------------------------
	Optionally define 
		multiple configurations 
		for the same provider
	select which one to use on 
		per-resource 
	or 
		per-module basis. 
	Why?
		support multiple regions 
		targeting multiple Docker hosts
		multiple Consul hosts, etc.
	To create multiple configurations for a provider, 
		include multiple 
			provider blocks 
			with the same provider name. 
	For each additional non-default configuration, 
		use "alias" meta-argument 
		to provide an extra name segment. 

	For example:
# The default provider configuration; resources that begin with `aws_` will use
# it as the default, and it can be referenced as `aws`.
provider "aws" {
  region = "us-east-1"
}

# Additional provider configuration for west coast region; resources can
# reference this as `aws.west`.
provider "aws" {
  alias  = "west"	#This is critical
  region = "us-west-2"
}

	To declare a configuration alias within a module
		add "configuration_aliases" argument 
		as below:

terraform {
  required_providers {
    mycloud = {
      source  = "mycorp/mycloud"
      version = "~> 1.0"
      configuration_aliases = [ mycloud.alternate ]
    }
  }
}

	Default Provider Configurations
	-------------------------------
		default: 
			provider block without alias 
	
	Referring to Alternate Provider Configurations
	----------------------------------------------
	Refer as 
		<PROVIDER NAME>.<ALIAS>. 
	e.g.		
		aws.west 
			refer to us-west-2 region.

			not strings 
			don't need to be quoted. 
	
	
	Selecting Alternate Provider Configurations
	---------------------------------------------
	To use 
		alternate provider configuration for 
			a resource or 
			data source
		set its 
			provider meta-argument to a 
				<PROVIDER NAME>.<ALIAS> reference:

resource "aws_instance" "foo" {
  provider = aws.west

  # ...
}

N.B: 
Child Modules
	A Terraform module 
		root module
			can call other modules 
				called child modules
				to include their resources 
					into the configuration. 
To select alternate provider configurations for a child module
	use its providers meta-argument:

module "aws_vpc" {
  source = "./another_aws_vpc"
  providers = {
    aws = aws.west
  }
}


	Most cases, 
		only root modules 
			should define provider configurations
		child modules 
			obtain their provider configurations from their parents.
	version (Deprecated)
	--------------------
	The version argument in provider configurations is deprecated. 
	In Terraform 0.13 and later
	always declare provider version constraints in the required_providers block. 
	
	------------------------------------------------------------------------------------------------------	
	Step-02: Implement Terraform Multiple Providers & Clean-Up
	------------------------------------------------------------------------------------------------------

lab/3
# Provider-1 for EastUS (Default Provider)
provider "azurerm" {
  features {}
}

# Provider-2 for WestUS Region
provider "azurerm" {
  features {
    virtual_machine {
      delete_os_disk_on_deletion = false # This will ensure when the Virtual Machine is destroyed, Disk is not deleted, default is true and we can alter it at provider level
    }
  }
  alias = "provider2-westus"
  #client_id = "XXXX"
  #client_secret = "YYY"
  #environment = "german"
  #subscription_id = "JJJJ"
}

resource "azurerm_resource_group" "myrg1" {
  name = "myrg-2"
  location = "West US"
    #<PROVIDER NAME>.<ALIAS NAME>
  provider = azurerm
}

resource "azurerm_resource_group" "myrg2" {
  name = "myrg-2"
  location = "West US"
    #<PROVIDER NAME>.<ALIAS NAME>
  provider = azurerm.provider2-westus
}



------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
Terraform Dependency Lock File
------------------------------------------------------------------------------------------------------
	Step-02: Create RG and Random String Resource
	------------------------------------------------------------------------------------------------------
		https://github.com/vilasvarghese/terraform-tutorial/blob/master/azure/01_1ResourceGroup/main.tf
		
		Randomn RG 
			https://www.lightenna.com/tech/2019/terraform-resource-groups-in-Azure/
	------------------------------------------------------------------------------------------------------	
	Step-03: Create Terraform Storage Account Resource
	------------------------------------------------------------------------------------------------------
	
	An Azure storage account 
		store data objects
		including 
			blobs, 
			file shares, 
			queues, 
			tables, and 
			disks. 
		provides a unique namespace for your Azure Storage data 
			accessible from anywhere in the world over 
				HTTP or HTTPS. 
		Data in your storage account is 
			durable  
			highly available
			secure 
			massively scalable.
	

lab/4
provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_storage_account" "example" {
  name                     = "storageaccountname"	#This should be unique
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "GRS"

  tags = {
    environment = "staging"
  }
}


arguments are supported:
	name - 
		(Required) 
		Only lowercase Alphanumeric characters allowed. 
		Change this 
			a new resource will be created. 
		Must be unique across 
			Azure service
			not just within the resource group.

	resource_group_name - 
		(Required) 
		Change this 
			new resource to be created.

	location - 
		(Required) 
		Specifies the supported Azure location 
		Change this 
			a new resource will be created.

	account_kind - 
		(Optional) 
		Defines the Kind of account. 
		Valid options are 
			BlobStorage, 
			BlockBlobStorage, 
			FileStorage, 
			Storage and 
			StorageV2. 
		Changing this forces a new resource to be created. 
		Defaults to StorageV2.

https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account

	
	
	------------------------------------------------------------------------------------------------------	
	Step-04: Dependency Lock File Demo and CleanUp
	------------------------------------------------------------------------------------------------------
	
8

Terraform configuration 
	has two external dependency
	(outside it's code base)
		Providers
		Modules
	
	version constraints
		define compatible dependency
	Dependency lock file:
		after selecting specific version 
		terraform remembers decision based on 
			dependency lock file
		so same decision can be made again
		Location: 
			current directory
	N.B: Currently supports only provider dependencies
		For module use exact version. Don't use >=
		
	Advantages of lock file
	-----------------------
		Without lock file
			download the latest version among supported
				defined in required_providers block
		With lock file
			always install same provider version
			dev./stage/production parity.
			
			
		

In provider block, features {} block is not present in Azure RM provider verion 1.44.0
	
lab/5
# Terraform Block
terraform {
  required_version = ">= 1.0.0"
  required_providers {
    azurerm = {
      source = "hashicorp/azurerm"
      version = "1.44.0"
      #version = ">= 2.0" # Commented for Dependency Lock File Demo, uncomment and run. Verify the version
    }
    random = {
      source = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}

# Provider Block
provider "azurerm" {
# features {}          # Commented for Dependency Lock File Demo
}

resource "azurerm_resource_group" "myrg1" {
  name     = "myrg1"
  location = "East US"
}

resource "random_string" "myrandom" {
  length = 16
  special = true
  upper = false
}

resource "azurerm_storage_account" "mysa" {
  name = "mysa${random_string.myrandom.id}"
  resource_group_name      = azurerm_resource_group.myrg1.name
  location                 = azurerm_resource_group.myrg1.location
  account_tier             = "Standard"
  account_replication_type = "GRS"
  account_encryption_source = "Microsoft.Storage"

  tags = {
    environment = "staging"
  }
}




Step
	Create with version = "1.44.0"


	

# We will start with Base v1.44 `.terraform.lock.hcl` file
cp .terraform.lock.hcl-v1.44 .terraform.lock.hcl


# Initialize Terraform
terraform init

# Compare both files
diff .terraform.lock.hcl-v1.44 .terraform.lock.hcl

# Validate Terraform Configuration files
terraform validate

# Execute Terraform Plan
terraform plan

# Create Resources using Terraform Apply
terraform apply


	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------
Terraform Resource Syntax and Behaviour
------------------------------------------------------------------------------------------------------
	Step-01: Terraform Resource Syntax Introduction
	------------------------------------------------------------------------------------------------------
lab/6	
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}

# Configure the Microsoft Azure Provider
provider "azurerm" {
  features {}
}

# Create a resource group
resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

# Create a virtual network within the resource group
resource "azurerm_virtual_network" "example" {
  name                = "example-network"
  resource_group_name = azurerm_resource_group.example.name
  location            = azurerm_resource_group.example.location
  address_space       = ["10.0.0.0/16"]
}
	------------------------------------------------------------------------------------------------------	
	Step-02: Create TF Config for Virtual Network
	------------------------------------------------------------------------------------------------------
	Manages a virtual network including any configured subnets. 
	Each subnet can be configured with a security group to be associated with the subnet.
	
lab/7
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}
provider "azurerm" {
  features {}
}	

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_network_security_group" "example" {
  name                = "example-security-group"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name
}

resource "azurerm_virtual_network" "example" {
  name                = "example-network"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name
  address_space       = ["10.0.0.0/16"]
  dns_servers         = ["10.0.0.4", "10.0.0.5"]

  subnet {
    name           = "subnet1"
    address_prefix = "10.0.1.0/24"
  }

  subnet {
    name           = "subnet2"
    address_prefix = "10.0.2.0/24"
    security_group = azurerm_network_security_group.example.id
  }

  tags = {
    environment = "Production"
  }
}

Arguments
---------
name - 
	(Required) 
	name of the virtual network. 
	Change it	
		new resource to be created.

resource_group_name - 
	(Required) 
	
	
address_space - 
	(Required) 
	address space 
	more than one address supported.

location - (Required) 
	The location/region where the virtual network is created. Changing this forces a new resource to be created.

ddos_protection_plan - 
	(Optional) 
	ddos_protection_plan block 
dns_servers - 
	(Optional) 
	List of IP addresses of DNS servers

NOTE
Since dns_servers can be 
	inline 
	separate azurerm_virtual_network_dns_servers resource, 
	
edge_zone - (Optional) 
	Specifies the Edge Zone in Azure Region 
	Change 
		new Virtual Network to be created.

flow_timeout_in_minutes - 
	(Optional) 
	flow timeout in minutes 
	Possible values are between 4 and 30 minutes.

subnet - 
	(Optional) 
	multiple times 
		to define multiple subnets. 
	can be 
		inline and 
		via separate azurerm_subnet resource

tags - 
	(Optional) 

Timeouts
The timeouts block allows you to specify timeouts for certain actions:

create - 
	(Defaults to 30 minutes) 
	Used when creating the Virtual Network.
update - 
	(Defaults to 30 minutes) 
	Used when updating the Virtual Network.
read - 
	(Defaults to 5 minutes) 
	Used when retrieving the Virtual Network.
delete - 
	(Defaults to 30 minutes) 
	Used when deleting the Virtual Network.

Import
Virtual Networks can be imported using the resource id, e.g.
terraform import 
	azurerm_virtual_network.exampleNetwork /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/mygroup1/providers/Microsoft.Network/virtualNetworks/myvnet1


	
	------------------------------------------------------------------------------------------------------	
	Step-03: Create TF Config for Subnet, Public IP and Network Interface
	------------------------------------------------------------------------------------------------------
https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/network_interface

Configuration with Network Interface
lab/8
------------------------------------------------------------

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}
provider "azurerm" {
  features {}
}	
resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_virtual_network" "example" {
  name                = "example-network"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name
}

resource "azurerm_subnet" "example" {
  name                 = "internal"
  resource_group_name  = azurerm_resource_group.example.name
  virtual_network_name = azurerm_virtual_network.example.name
  address_prefixes     = ["10.0.2.0/24"]
}

resource "azurerm_network_interface" "example" {
  name                = "example-nic"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.example.id
    private_ip_address_allocation = "Dynamic"
  }
}

------------------------------------------------------------
The following arguments are supported in:
azurerm_network_interface
ip_configuration - 
	(Required) 
	One or more ip_configuration blocks.

location - 
	(Required) 
	The location of Network Interface. 
	Change this 
		a new resource to be created.

name - 
	(Required) 
	The name of the Network Interface. 
	Change this forces a new resource to be created.

resource_group_name - 
	(Required) 
	The name of the Resource Group of the Network Interface. 
	Changing this forces a new resource to be created.

dns_servers - 
	(Optional) 
	list of IP Addresses 
Note: 
	will override the DNS Servers defined on the "Virtual Network".

edge_zone - 
	(Optional) 
	Change this 
		new Network Interface to be created.

enable_ip_forwarding - 
	(Optional) Should IP Forwarding be enabled? 
	Defaults to false.

enable_accelerated_networking - 
	(Optional) Should Accelerated Networking be enabled? 
	Defaults to false.

Note:
Check if Virtual Machine sizes are supported for Accelerated Networking 

Note:
	To use Accelerated Networking in an Availability Set, 
	the Availability Set must be deployed onto an Accelerated Networking enabled cluster.

internal_dns_name_label - 
	(Optional) The (relative) DNS Name used for internal communications between Virtual Machines in the same Virtual Network.

tags - 
	(Optional) A mapping of tags to assign to the resource.

The ip_configuration block supports the following:

name - 
	(Required) A name used for this IP Configuration.

gateway_load_balancer_frontend_ip_configuration_id - 
	(Optional) 
	The Frontend IP Configuration ID of a Gateway SKU Load Balancer.

subnet_id - 
	(Optional) 
	The ID of the Subnet where this Network Interface should be located in.

Note:
This is required when private_ip_address_version is set to IPv4.

private_ip_address_version - 
	(Optional) 
	The IP Version to use. Possible values are IPv4 or IPv6. Defaults to IPv4.

private_ip_address_allocation - 
	(Required) 
	values: Dynamic and Static.

Note:
	Dynamic 
		"An IP is automatically assigned 
			during creation of this Network Interface"; 
	Static 
		"User supplied IP address will be used"

public_ip_address_id - 
	(Optional) 
	Reference to a Public IP Address to associate with this NIC

primary - 
	(Optional) 
	Must be true for the first ip_configuration 
		when multiple are specified. 
	Defaults to false.

When private_ip_address_allocation is set to Static the following fields can be configured:

private_ip_address - 
	(Optional) The Static IP Address which should be used.
	When private_ip_address_version is set to IPv4 the following fields can be configured:

subnet_id - 
	(Required) The ID of the Subnet where this Network Interface should be located in.

Attributes Reference
The following attributes are exported:

applied_dns_servers - If the Virtual Machine using this Network Interface is part of an Availability Set, then this list will have the union of all DNS servers from all Network Interfaces that are part of the Availability Set.

id - The ID of the Network Interface.

internal_domain_name_suffix - Even if internal_dns_name_label is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internal_domain_name_suffix.

mac_address - The Media Access Control (MAC) Address of the Network Interface.

private_ip_address - The first private IP address of the network interface.

Note:
If a Dynamic allocation method is used Azure will allocate an IP Address on Network Interface creation.

private_ip_addresses - The private IP addresses of the network interface.
Note:
If a Dynamic allocation method is used Azure will allocate an IP Address on Network Interface creation.

virtual_machine_id - The ID of the Virtual Machine which this Network Interface is connected to.
Timeouts
The timeouts block allows you to specify timeouts for certain actions:

	create - (Defaults to 30 minutes) Used when creating the Network Interface.
	update - (Defaults to 30 minutes) Used when updating the Network Interface.
	read - (Defaults to 5 minutes) Used when retrieving the Network Interface.
	delete - (Defaults to 30 minutes) Used when deleting the Network Interface.


------------------------------------------------------------
lab/9
Create a public IP and create vnet with public IP

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}
provider "azurerm" {
  features {}
}	

# Resource-2: Create Virtual Network
resource "azurerm_virtual_network" "myvnet" {
  name                = "myvnet-1"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
}

# Resource-3: Create Subnet
resource "azurerm_subnet" "mysubnet" {
  name                 = "mysubnet-1"
  resource_group_name  = azurerm_resource_group.myrg.name
  virtual_network_name = azurerm_virtual_network.myvnet.name
  address_prefixes     = ["10.0.2.0/24"]
}

# Resource-4: Create Public IP Address
resource "azurerm_public_ip" "mypublicip" {
  name                = "mypublicip-1"
  resource_group_name = azurerm_resource_group.myrg.name
  location            = azurerm_resource_group.myrg.location
  allocation_method   = "Static"
  tags = {
    environment = "Dev"
  }
}

# Resource-5: Create Network Interface
resource "azurerm_network_interface" "myvm1nic" {
  name                = "vm1-nic"
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.mysubnet.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id = azurerm_public_ip.mypublicip.id 
  }
}


------------------------------------------------------------

	------------------------------------------------------------------------------------------------------	
	Step-04: Terraform Resource Behavior Introduction
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/resources
	https://www.terraform.io/language/resources/behavior
	
	
	Resources 
		most important element 
		resource block 
			describes one or more infrastructure objects
			e.g. 
				virtual networks, 
				compute instances, 
				or higher-level components 
					such as DNS records.

		Meta-Arguments 
			special arguments that can be used with every resource type
			e.g. 
				depends_on, 
				count, 
				for_each, 
				provider, and 
				lifecycle.

		Provisioners 
			configure post-creation actions 
			non-declarative 
			potentially unpredictable
			recommendation
				treat them as a last resort.


Resource Behavior
-----------------
resource block 
	declares 
		infrastructure object with the given settings. 
	Applying a Terraform configuration 
		process of 
			creating, 
			updating, and 
			destroying 
				real infrastructure objects 
		attempt to match actual state == desired state.

How Terraform Applies a Configuration
-------------------------------------
	For new infrastructure object represented by a resource block
		new object created
		identifier of object saved in Terraform's state
		allows to update  
			in response to future changes. 
	For existing resource blocks 
		object present in the state
		Terraform compares 
			actual infrastructure with configuration 
			updates the object to match the configuration.

So apply will:
	Create an infrastructure
		which is not present
	Destroy resources removed in configuration.
	Update in-place resources whose arguments have changed.
		refer command argument help.
	Destroy and re-create resources 
		if arguments have changed 
			cannot be updated in-place.

Accessing Resource Attributes
-----------------------------
Use 
	<RESOURCE TYPE>.<NAME>.<ATTRIBUTE> 
		to reference 
	Mostly
		read-only attributes 
		e.g. resource's unique random ID.

	Most providers also support data sources
		e.g. ami

Resource Dependencies
---------------------
Terraform can change
	unrelated resources in parallel.
But for dependent resources
	follow sequential execution

Most resource dependencies
	handled automatically. 

Terraform 
	analyses expressions in resource block 
		find references to other objects
		creates order for 
			creating, 
			updating, or 
			destroying resources. 
	
Some dependencies 
	cannot be recognized implicitly 
	For e.g., 
		create access control policies 
		take actions based on those policies 
			hidden dependency between 
				access policy and
				resource 
	Use meta-argument
		depends_on 
	or 
		replace_triggered_by 
			forces Terraform to replace 
				parent resource 
					when referenced resource or resource attribute changes

Local-only Resources
--------------------
specialized resource types 
	within Terraform itself
	e.g. 
		for generating private keys
		self-signed TLS certificates
		generate random ids. 
		
	lab already covered.	
		
behavior of local-only resources 
	same as other resources
		But: result data exists only within the Terraform state. 
	"Destroying" local resource 
		remove it from state, 
		discarding its data.
	
	More on resources below
	https://www.terraform.io/language/resources/syntax
	------------------------------------------------------------------------------------------------------	
	Step-05: Resource Behavior: Create Resource Demo
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-06: Understand Terraform State in detail
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/state
	
	State
	-----
	primary object for terraform to function
	database containing the resources information 
	When Terraform creates a remote object 
		record the identity of that remote object 
		against a resource instance
		potentially 
			update or delete that object 
			in response to future configuration changes.
	Terraform state file created when we first run the terraform apply
	Terraform state file is created locally in working directory.
	confiure the backend block 
		in terraform block 
			store state file remotely. 
	Storing remotely is recommended option 
		
	
		Terraform store state about 
			managed infrastructure and 
			configuration. 
		used to 
			map real world resources 
				to configuration
			create binding between 
				remote real world resources
				with config.
		why?	
			keep track of metadata
				for e.g. if you delete a config?
			improve performance.
			
		by default stored in 
			"terraform.tfstate"
				locally
			can store remotely
				for team 
				
		Prior to any operation
			Terraform refresh 
				update the state 
					with the real infrastructure.

https://www.terraform.io/language/state/purpose

Purpose of Terraform State
--------------------------
	to 
		Map to the Real World
		manage Metadata
		for Syncing
	
Mapping to the Real World
-------------------------
	Terraform requires some database 
		to map Terraform config 
			to the real world. 
	for e.g.
		to delete the resource
	
	
	For some providers like AWS
		could have used AWS tags. 
			Early prototypes implementation used tags
	problems
		1: not all resources support tags
		2: not all cloud providers support tags.

	So Terraform uses states
	
	each remote object 
		bound to only one resource instance in the configuration. 
	

Metadata
---------
	Terraform must also track 
		metadata 
			like resource dependencies.
	While deleting resources, 
		terraform should find
			order of deleting
			e.g. vm before subnet.
		dependency can be complicated if multiple providers are present
	
Performance
-----------
	performance improvement
		optional feature of Terraform state 
	When running a terraform plan, 
		Terraform must 
			know the current state 
				to determine the changes.
	default behavior of Terraform: 
		for every plan and apply, 
		sync all resources in your state.
	Problem with refresh
		For each infra.
			Very slow
		Rate limiting can block
	Solution
		use 
			-refresh=false flag and 
				terraform plan -refresh=false or 
				terraform apply -refresh=false.
				Reference: https://www.terraform.io/cloud-docs/run/modes-and-options
			-target flag 
		cached state is treated as the record of truth.

Syncing
-------
	
	Remote state 
		working in team.
		can use remote locking 
			avoid multiple users 
				accidentally running Terraform at the same time
			
			

Inspection and Modification
---------------------------
	direct file editing of the state is discouraged. 
	terraform state command 
		basic modifications of the state using the CLI.

	Terraform expects a one-to-one mapping 
		Normally that is guaranteed by Terraform 

	If you add or remove bindings in the state by other means
		e.g. import externally-created objects with terraform import
	or	
		ask Terraform to "forget" an existing object 
			terraform state rm
			
		we have to ensure one-to-one relation maintained
			manually manage
			terraform import
			
Format
------
	State snapshots 
		stored in JSON format 
	
	terraform output command 
		has a -json option, for obtaining either the full set of root module output values or a specific named output value from the latest state snapshot.
	The terraform show command has a -json option for inspecting the latest state snapshot in full, and also for inspecting saved plan files which include a  of the prior state at the time the plan was made.
	A typical way to use these in situations where Terraform is running in automation is to run them immediately after a successful terraform apply to obtain a representation of the latest state snapshot, and then store that result as an artifact associated with the automated run so that other software can potentially consume it without needing to run Terraform itself.
	
	




	------------------------------------------------------------------------------------------------------	
	Step-07: Resource Behavior: Update-In-Place, Destroy-Recreate and Destroy Demo's
	------------------------------------------------------------------------------------------------------
		9
		
	Update-In-Place	
		In place update
From lab/9
	Add tags = {
		"Name" = vilasvnet
		"Environment" = "Dev"
	}
		
	terraform validate
	terraform plan
		Check update in-place
		
	Destroy-Recreate
		destroy and create resource
		
	Change 
		name of network_interface
	terraform validate
	terraform plan
	
	https://www.terraform.io/cli/state/taint
Forcing Re-creation of Resources
--------------------------------
During planning
	default 
		retrieves the latest state 
			of each existing object and 
		compares it 
			with the current configuration, 
		plan actions 
			only against objects 
		current state 
			does not match the configuration.

In some cases 
	remote object get 
		damaged or 
		degraded 
			Terraform cannot automatically detect. 
	For e.g., 
		if app in vm crashes 
	We can force a replace
		-replace=
	
lab/...
	Update name
	terraform apply fails
	terraform apply -replace=azurerm_network_interface.myvm1nic
	
$ terraform apply -replace=aws_instance.example
  # aws_instance.example will be replaced, as requested

The "tainted" status
--------------------
	Sometimes Terraform 
		can detect the damage
	for e.g.
		creation of a complex object 
			partially fails
		e.g. provisioner fails.

	Terraform marks an object in the state as "tainted". 
	Impact:
		next plan will force replace
			similar to -replace we manually specify.

	  # aws_instance.example is tainted, so must be replaced
	-/+ resource "aws_instance" "example" {
		  # ...
		}

Force Taint/Untaint
-------------------
If Terraform mark an object as tainted 
	but is working correctly 
	don't want to replace 
	we can override Terraform
		use terraform untaint command
	
We can force Terraform 
	mark an object as tainted 
	use 
		deprecated: terraform taint command
	 for
		-replace=	
		
	------------------------------------------------------------------------------------------------------	
	Step-08: Understand Terraform Desired and Current States and CleanUp
	------------------------------------------------------------------------------------------------------
	https://awstip.com/terraform-understanding-desired-current-state-176ffb13e213
	
	https://maazdba.blogspot.com/2020/09/terraform-diary-desired-state-and.html
	
	
	------------------------------------------------------------------------------------------------------	

Day 2
------------------------------------------------------------------------------------------------------
Terraform meta argument depend_on
------------------------------------------------------------------------------------------------------
	Step-00: All Meta-Arguments Introduction
	------------------------------------------------------------------------------------------------------
Resource behavior 
	can be customized 
	use nested lifecycle block 
		in a resource block body:
	
	supported options
		depends_on
			manage dependencies which terraform cannot identify
		count
			create multiple resources
		for_each
			create multiple types of resources
			can use 
				map
				set of string
		provider
			select non-default provider
		lifecycle
			modify the default behaviour


	
	
	------------------------------------------------------------------------------------------------------	
	Step-01: Introduction to Meta-Argument depends_on
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/meta-arguments/depends_on
	10
	
	depends_on 
		meta-argument 
		handle 
			hidden resource or 
			module dependencies 
		that Terraform cannot automatically infer.
		Available in 
			module and 
			resource 
				blocks
		Defines a list of references to 
			other resources
		or 
			child modules
		expressions are not allowed in depends_on	


	required only when
		depends_on
			a resource 
				depends on another resource
			but	
				doesn't access any property
					in configuration

	------------------------------------------------------------------------------------------------------	
	Step-02: Execute TF Commands without depends_on and understand Terraform Behavior
	------------------------------------------------------------------------------------------------------
terraform init
terraform validate
terraform plan
terraform apply -auto-approve
terraform destroy -auto-approve

lab/10	
# Terraform Block
terraform {
  required_version = ">= 1.0.0"
  required_providers {
    azurerm = {
      source = "hashicorp/azurerm"
      version = ">= 2.0" 
    }
    random = {
      source = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}

# Provider Block
provider "azurerm" {
 features {}          
}

# Random String Resource
resource "random_string" "myrandom" {
  length = 6
  upper = false 
  special = false
  number = false   
}

# Resource-1: Azure Resource Group
resource "azurerm_resource_group" "myrg" {
  name = "myrg-1"
  location = "East US"
}

# Create Virtual Network
resource "azurerm_virtual_network" "myvnet" {
  name                = "myvnet-1"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
}

# Create Subnet
resource "azurerm_subnet" "mysubnet" {
  name                 = "mysubnet-1"
  resource_group_name  = azurerm_resource_group.myrg.name
  virtual_network_name = azurerm_virtual_network.myvnet.name
  address_prefixes     = ["10.0.2.0/24"]
}

# Create Public IP Address
resource "azurerm_public_ip" "mypublicip" {
  name                = "mypublicip-1"
  resource_group_name = azurerm_resource_group.myrg.name
  location            = azurerm_resource_group.myrg.location
  allocation_method   = "Static"
  domain_name_label = "app1-vm-${random_string.myrandom.id}"
  tags = {
    environment = "Dev"
  }
}

# Create Network Interface
resource "azurerm_network_interface" "myvmnic" {
  name                = "vmnic"
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name

  ip_configuration {
    name                          = "internal"
    subnet_id                     = azurerm_subnet.mysubnet.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id = azurerm_public_ip.mypublicip.id 
  }
}

# Create Public IP Address
resource "azurerm_public_ip" "mypublicip" {
  # Add Explicit Dependency to have this resource created only after Virtual Network and Subnet Resources are created. 
  depends_on = [
    azurerm_virtual_network.myvnet,
    azurerm_subnet.mysubnet
  ]
  name                = "mypublicip-1"
  resource_group_name = azurerm_resource_group.myrg.name
  location            = azurerm_resource_group.myrg.location
  allocation_method   = "Static"
  domain_name_label = "app1-vm-${random_string.myrandom.id}"
  tags = {
    environment = "Dev"
  }
}

	------------------------------------------------------------------------------------------------------	
	Step-03: Execute TF Commands with depends_on and understand Terraform Behavior
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/meta-arguments/depends_on
	
	

Processing and Planning Consequences
------------------------------------
depends_on 
	instructs Terraform 
		complete all actions on the dependency object 
			(including Read actions) 
		before performing actions on the object declaring the dependency. 
	Recommendation:	
		use it as last resort 
		instead use
			expression references
		because 
			Terraform takes conservative plans 
				treat more values as unknown
			replace more resources than necessary. 


	
Provison Azure Linux vm with file and filebase64
------------------------------------------------------------------------------------------------------
	Step-01: Introduction to Azure Linux VM using Terraform
	------------------------------------------------------------------------------------------------------
	
	Create the below Azure Resources using Terraform
		Azure Resource Group
		Azure Virtual Network
		Azure Subnet
		Azure Public IP
		Azure Network Interface
		Azure Linux Virtual Machine
		random_string Resource
	
	
lab/11
\HSBGInfotech\Others\vilas\terraform-tutorial\azure\steps\11

	
	https://learn.microsoft.com/en-us/azure/virtual-machines/linux/quick-create-terraform
	https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/linux_virtual_machine
	
	
	
Terraform will 
	automatically remove the OS 
		Disk by default 
			can be configured 



Argument Reference
The following arguments are supported:

Below arguments are both
	Change below new resource to be created.
	and 
		(Required)

		admin_username - 
		location - 
		name 

Below arguments are 
	Required	
		network_interface_ids
			A list of Network Interface IDs
			first Network Interface ID: Primary 

	(Optional)

resource_group_name - (Required) The name of the Resource Group in which the Linux Virtual Machine should be exist. Changing this forces a new resource to be created.

size - (Required) The SKU which should be used for this Virtual Machine, such as Standard_F2.

additional_capabilities - (Optional) A additional_capabilities block as defined below.

admin_password - (Optional) The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.

NOTE:
When an admin_password is specified disable_password_authentication must be set to false. ~> NOTE: One of either admin_password or admin_ssh_key must be specified.

admin_ssh_key - (Optional) One or more admin_ssh_key blocks as defined below.
NOTE:
One of either admin_password or admin_ssh_key must be specified.

allow_extension_operations - (Optional) Should Extension Operations be allowed on this Virtual Machine?

availability_set_id - (Optional) Specifies the ID of the Availability Set in which the Virtual Machine should exist. Changing this forces a new resource to be created.

boot_diagnostics - (Optional) A boot_diagnostics block as defined below.

capacity_reservation_group_id - (Optional) Specifies the ID of the Capacity Reservation Group which the Virtual Machine should be allocated to.

NOTE:
capacity_reservation_group_id cannot be used with availability_set_id or proximity_placement_group_id

computer_name - (Optional) Specifies the Hostname which should be used for this Virtual Machine. If unspecified this defaults to the value for the name field. If the value of the name field is not a valid computer_name, then you must specify computer_name. Changing this forces a new resource to be created.

custom_data - 
	(Optional) 
	Base64-Encoded Custom Data 
		used for this Virtual Machine. 
	Change  it
		new resource will be created.

dedicated_host_id - (Optional) The ID of a Dedicated Host where this machine should be run on. Conflicts with dedicated_host_group_id.

dedicated_host_group_id - (Optional) The ID of a Dedicated Host Group that this Linux Virtual Machine should be run within. Conflicts with dedicated_host_id.

disable_password_authentication - (Optional) Should Password Authentication be disabled on this Virtual Machine? Defaults to true. Changing this forces a new resource to be created.

Note
In general we'd recommend using SSH Keys for authentication rather than Passwords - but there's tradeoff's to each - please see this thread for more information.

NOTE:
When an admin_password is specified disable_password_authentication must be set to false.

edge_zone - (Optional) Specifies the Edge Zone within the Azure Region where this Linux Virtual Machine should exist. Changing this forces a new Linux Virtual Machine to be created.

encryption_at_host_enabled - (Optional) Should all of the disks (including the temp disk) attached to this Virtual Machine be encrypted by enabling Encryption at Host?

eviction_policy - (Optional) Specifies what should happen when the Virtual Machine is evicted for price reasons when using a Spot instance. Possible values are Deallocate and Delete. Changing this forces a new resource to be created.

NOTE:
This can only be configured when priority is set to Spot.

extensions_time_budget - (Optional) Specifies the duration allocated for all extensions to start. The time duration should be between 15 minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. Defaults to 90 minutes (PT1H30M).

identity - (Optional) An identity block as defined below.

patch_mode - (Optional) Specifies the mode of in-guest patching to this Linux Virtual Machine. Possible values are AutomaticByPlatform and ImageDefault. Defaults to ImageDefault. For more information on patch modes please see the product documentation.

NOTE:
If patch_mode is set to AutomaticByPlatform then provision_vm_agent must also be set to true.

max_bid_price - (Optional) The maximum price you're willing to pay for this Virtual Machine, in US Dollars; which must be greater than the current spot price. If this bid price falls below the current spot price the Virtual Machine will be evicted using the eviction_policy. Defaults to -1, which means that the Virtual Machine should not be evicted for price reasons.
NOTE:
This can only be configured when priority is set to Spot.

plan - (Optional) A plan block as defined below. Changing this forces a new resource to be created.

platform_fault_domain - (Optional) Specifies the Platform Fault Domain in which this Linux Virtual Machine should be created. Defaults to -1, which means this will be automatically assigned to a fault domain that best maintains balance across the available fault domains. Changing this forces a new Linux Virtual Machine to be created.

priority- (Optional) Specifies the priority of this Virtual Machine. Possible values are Regular and Spot. Defaults to Regular. Changing this forces a new resource to be created.

provision_vm_agent - (Optional) Should the Azure VM Agent be provisioned on this Virtual Machine? Defaults to true. Changing this forces a new resource to be created.

NOTE:
If provision_vm_agent is set to false then allow_extension_operations must also be set to false.

proximity_placement_group_id - (Optional) The ID of the Proximity Placement Group which the Virtual Machine should be assigned to.

secret - (Optional) One or more secret blocks as defined below.

secure_boot_enabled - (Optional) Specifies whether secure boot should be enabled on the virtual machine. Changing this forces a new resource to be created.

source_image_id - (Optional) The ID of the Image which this Virtual Machine should be created from. Changing this forces a new resource to be created. Possible Image ID types include Image IDs, Shared Image IDs, Shared Image Version IDs, Community Gallery Image IDs, Community Gallery Image Version IDs, Shared Gallery Image IDs and Shared Gallery Image Version IDs.

NOTE:
One of either source_image_id or source_image_reference must be set.

source_image_reference - (Optional) A source_image_reference block as defined below. Changing this forces a new resource to be created.
NOTE:
One of either source_image_id or source_image_reference must be set.

tags - (Optional) A mapping of tags which should be assigned to this Virtual Machine.

termination_notification - (Optional) A termination_notification block as defined below.

user_data - (Optional) The Base64-Encoded User Data which should be used for this Virtual Machine.

vtpm_enabled - (Optional) Specifies whether vTPM should be enabled on the virtual machine. Changing this forces a new resource to be created.

virtual_machine_scale_set_id - (Optional) Specifies the Orchestrated Virtual Machine Scale Set that this Virtual Machine should be created within. Changing this forces a new resource to be created.

NOTE:
Orchestrated Virtual Machine Scale Sets can be provisioned using the azurerm_orchestrated_virtual_machine_scale_set resource.

zone - (Optional) Specifies the Availability Zones in which this Linux Virtual Machine should be located. Changing this forces a new Linux Virtual Machine to be created.
A additional_capabilities block supports the following:

ultra_ssd_enabled - (Optional) Should the capacity to enable Data Disks of the UltraSSD_LRS storage account type be supported on this Virtual Machine? Defaults to false.
A admin_ssh_key block supports the following:

public_key - (Required) The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format. Changing this forces a new resource to be created.

username - (Required) The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.

NOTE:
The Azure VM Agent only allows creating SSH Keys at the path /home/{username}/.ssh/authorized_keys - as such this public key will be written to the authorized keys file.

A boot_diagnostics block supports the following:

storage_account_uri - (Optional) The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
NOTE:
Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics

A certificate block supports the following:

url - (Required) The Secret URL of a Key Vault Certificate.
NOTE:
This can be sourced from the secret_id field within the azurerm_key_vault_certificate Resource.

A diff_disk_settings block supports the following:

option - (Required) Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is Local. Changing this forces a new resource to be created.

placement - (Optional) Specifies where to store the Ephemeral Disk. Possible values are CacheDisk and ResourceDisk. Defaults to CacheDisk. Changing this forces a new resource to be created.

An identity block supports the following:

type - (Required) Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are SystemAssigned, UserAssigned, SystemAssigned, UserAssigned (to enable both).

identity_ids - (Optional) Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.

NOTE:
This is required when type is set to UserAssigned or SystemAssigned, UserAssigned.

A os_disk block supports the following:

caching - (Required) The Type of Caching which should be used for the Internal OS Disk. Possible values are None, ReadOnly and ReadWrite.

storage_account_type - (Required) The Type of Storage Account which should back this the Internal OS Disk. Possible values are Standard_LRS, StandardSSD_LRS, Premium_LRS, StandardSSD_ZRS and Premium_ZRS. Changing this forces a new resource to be created.

diff_disk_settings (Optional) A diff_disk_settings block as defined above. Changing this forces a new resource to be created.

NOTE:
diff_disk_settings can only be set when caching is set to ReadOnly. More information can be found here

disk_encryption_set_id - (Optional) The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with secure_vm_disk_encryption_set_id.
NOTE:
The Disk Encryption Set must have the Reader Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault

disk_size_gb - (Optional) The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
NOTE:
If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.

name - (Optional) The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.

secure_vm_disk_encryption_set_id - (Optional) The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with disk_encryption_set_id. Changing this forces a new resource to be created.

NOTE:
secure_vm_disk_encryption_set_id can only be specified when security_encryption_type is set to DiskWithVMGuestState.

security_encryption_type - (Optional) Encryption Type when the Virtual Machine is a Confidential VM. Possible values are VMGuestStateOnly and DiskWithVMGuestState. Changing this forces a new resource to be created.
NOTE:
secure_boot_enabled and vtpm_enabled must be set to true when security_encryption_type is specified.

NOTE:
encryption_at_host_enabled cannot be set to true when security_encryption_type is set to DiskWithVMGuestState.

write_accelerator_enabled - (Optional) Should Write Accelerator be Enabled for this OS Disk? Defaults to false.
NOTE:
This requires that the storage_account_type is set to Premium_LRS and that caching is set to None.

A plan block supports the following:

name - (Required) Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.

product - (Required) Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.

publisher - (Required) Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.

A secret block supports the following:

certificate - (Required) One or more certificate blocks as defined above.

key_vault_id - (Required) The ID of the Key Vault from which all Secrets should be sourced.

source_image_reference supports the following:

publisher - (Optional) Specifies the publisher of the image used to create the virtual machines.

offer - (Optional) Specifies the offer of the image used to create the virtual machines.

sku - (Optional) Specifies the SKU of the image used to create the virtual machines.

version - (Optional) Specifies the version of the image used to create the virtual machines.

A termination_notification block supports the following:

enabled - (Required) Should the termination notification be enabled on this Virtual Machine? Defaults to false.

timeout - (Optional) Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format.

NOTE:
For more information about the termination notification, please refer to this doc.

Attributes Reference
In addition to all arguments above, the following attributes are exported:

id - The ID of the Linux Virtual Machine.

identity - An identity block as documented below.

private_ip_address - The Primary Private IP Address assigned to this Virtual Machine.

private_ip_addresses - A list of Private IP Addresses assigned to this Virtual Machine.

public_ip_address - The Primary Public IP Address assigned to this Virtual Machine.

public_ip_addresses - A list of the Public IP Addresses assigned to this Virtual Machine.

virtual_machine_id - A 128-bit identifier which uniquely identifies this Virtual Machine.

An identity block exports the following:

principal_id - The Principal ID associated with this Managed Service Identity.

tenant_id - The Tenant ID associated with this Managed Service Identity.

Timeouts
The timeouts block allows you to specify timeouts for certain actions:

create - (Defaults to 45 minutes) Used when creating the Linux Virtual Machine.
update - (Defaults to 45 minutes) Used when updating the Linux Virtual Machine.
delete - (Defaults to 45 minutes) Used when deleting the Linux Virtual Machine.
	------------------------------------------------------------------------------------------------------	
	Step-02: Create TF Config for Azure Linux VM
	------------------------------------------------------------------------------------------------------

already covered above

	------------------------------------------------------------------------------------------------------	
	Step-03: Review CloudInit file for custom_data and filebase64 function
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/functions/filebase64
	https://stackoverflow.com/questions/69709119/why-do-i-get-contents-of-zip-are-not-valid-utf-8-when-using-filebase64sha256
	
	
	------------------------------------------------------------------------------------------------------	
	Step-04: Execute TF Commands, Verify and Clean-Up Azure All resources
------------------------------------------------------------------------------------------------------
Terraform meta argument with Element Function and Splat Expression
------------------------------------------------------------------------------------------------------
	Step-01: Introduction to Meta-Argument count
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/meta-arguments/count
	11-02

The count Meta-Argument
	count was added in Terraform 0.13
	a resource or module block 
		cannot use both 
			count and for_each.

	Count accepts 
		whole number
		numeric expressions
	Terraform will create so many instances 
	Each instance 
		distinct infra. object associated with it
		separately
			created
			updated
			destroyed
	value should be pre-defined
	instances identified by index number starting 0
	count.index 
		index number starting with 0

lab/12
	Refer vilas\terraform-tutorial\azure\steps\12
		
		
terraform console #Gives access to try scripts in terraform
element(["Vilas", "Varghese", "Bangalore"], 0)
element(["Vilas", "Varghese", "Bangalore"], 1)
element(["Vilas", "Varghese", "Bangalore"], 2)

# To get last element from list
length(["Vilas", "Varghese", "Bangalore"])
element(["Vilas", "Varghese", "Bangalore"], length(["Vilas", "Varghese", "Bangalore"])-1)	
		

lab/13		
	Modify the vm create example
	cp -r vilas\terraform-tutorial\azure\steps\11 11-count
	Refer vilas\terraform-tutorial\azure\steps\13\
	
	

Modify 
-------------------
By default, a resource block configures one real infrastructure object. (Similarly, a module block includes a child module's contents into the configuration one time.) However, sometimes you want to manage several similar objects (like a fixed pool of compute instances) without writing a separate block for each one. Terraform has two ways to do this: count and for_each.

If a resource or module block includes a count argument whose value is a whole number, Terraform will create that many instances.

Basic Syntax
count is a meta-argument defined by the Terraform language. It can be used with modules and with every resource type.

The count meta-argument accepts a whole number, and creates that many instances of the resource or module. Each instance has a distinct infrastructure object associated with it, and each is separately created, updated, or destroyed when the configuration is applied.

resource "aws_instance" "server" {
  count = 4 # create four similar EC2 instances

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"

  tags = {
    Name = "Server ${count.index}"
  }
}

The count Object
In blocks where count is set, an additional count object is available in expressions, so you can modify the configuration of each instance. This object has one attribute:

count.index — The distinct index number (starting with 0) corresponding to this instance.
Using Expressions in count
The count meta-argument accepts numeric expressions. However, unlike most arguments, the count value must be known before Terraform performs any remote resource actions. This means count can't refer to any resource attributes that aren't known until after a configuration is applied (such as a unique ID generated by the remote API when an object is created).

Referring to Instances
When count is set, Terraform distinguishes between the block itself and the multiple resource or module instances associated with it. Instances are identified by an index number, starting with 0.

<TYPE>.<NAME> or module.<NAME> (for example, aws_instance.server) refers to the resource block.
<TYPE>.<NAME>[<INDEX>] or module.<NAME>[<INDEX>] (for example, aws_instance.server[0], aws_instance.server[1], etc.) refers to individual instances.
This is different from resources and modules without count or for_each, which can be referenced without an index or key.

Similarly, resources from child modules with multiple instances are prefixed with module.<NAME>[<KEY>] when displayed in plan output and elsewhere in the UI. For a module without count or for_each, the address will not contain the module index as the module's name suffices to reference the module.

Note: Within nested provisioner or connection blocks, the special self object refers to the current resource instance, not the resource block as a whole.

»When to Use for_each Instead of count
If your instances are almost identical, count is appropriate. If some of their arguments need distinct values that can't be directly derived from an integer, it's safer to use for_each.

Before for_each was available, it was common to derive count from the length of a list and use count.index to look up the original list value:

variable "subnet_ids" {
  type = list(string)
}

resource "aws_instance" "server" {
  # Create one instance for each subnet
  count = length(var.subnet_ids)

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
  subnet_id     = var.subnet_ids[count.index]

  tags = {
    Name = "Server ${count.index}"
  }
}


Count was fragile
	resource instances identified by their index 
		instead of the string values 
	If an element was removed from the middle 
		subnet_id for every instance after 
			would change, 
		more remote object changes than intended. 
	Solution:
		Use for_each.

	------------------------------------------------------------------------------------------------------	
	Step-02: Meta-Argument Count - Azure Resource Group Demo
	------------------------------------------------------------------------------------------------------
	
	covered with count
	------------------------------------------------------------------------------------------------------	
	Step-03: Introduction to Meta-Argument count for Azure Linux VM
	------------------------------------------------------------------------------------------------------
	
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-04: Learn Terraform Element, Length Functions and Splat Expressions
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/functions/length
	https://www.terraform.io/language/expressions/splat
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-05: Apply Element Function, Splat Expression to VMNIC and Linux VM
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-06: Execute Terraform Commands, Verify 2 Linux VMs and CleanUp
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------

Terraform meta argument for_each with Maps and set of string
------------------------------------------------------------------------------------------------------
	Step-02: Meta-Argument for_each with Maps Demo
	------------------------------------------------------------------------------------------------------
		https://www.terraform.io/language/meta-arguments/for_each
		12
		
	for_each
		similar to count. 
		but value can be 
			Map
			Set
			N.B: In count value is a number
		
		create an instance for each value

		each instance
			distinct infrastructure object associated with it
			is seperately
				created
				updated
				deleted

		additional each block
			each.key
				if Map, then key
				if set, then key and value are same.
				for_each=toset(["Vilas","Varghese"])
					each.key == each.value
					key[0] = value[0] = Vilas
					
			each.value
				if Map, then value
				for_each={
					dev="myapp1"
				}
				each.key = dev
				each.value = myapp1
		
lab/14		
vilas\terraform-tutorial\azure\steps\14		
	
	------------------------------------------------------------------------------------------------------	
	Step-03: for_each - Set of Strings Introduction and Terraform Console Command wi
	------------------------------------------------------------------------------------------------------
	
	toset 
		converts its argument to a set value. 
		does an explicit type conversion to normalize the types.
		all elements of set should be of same type
		mixed-typed elements 
			converted to most general type
		Set collections 
			unordered 
				ordering is lost
			duplicate values 
				ignored: lost
				
# Terraform console
terraform console

# All Strings to Strings
toset(["Vilas", "Varghese", "Bengaluru"])
#duplicates
toset(["Vilas", "Varghese", "Vilas"])

# Mixed Type (Strings and Numbers) - Converted to Strings 
toset(["Vilas", "Varghese", 123, 456])

# Also arranges in the order 
	(The order provided will be gone) 
toset([4, 100, 20, 11, 21, 7, 6, 4, 100])			
	------------------------------------------------------------------------------------------------------	
	Step-04: Implement for_each with set of strings
	------------------------------------------------------------------------------------------------------
	13
	
	
lab/15
	vilas\terraform-tutorial\azure\steps\15

	------------------------------------------------------------------------------------------------------	
	Step-05: for_each chaining Introduction and Review TF Configs
	------------------------------------------------------------------------------------------------------
	14
	
	Because a resource using for_each appears as a map of objects or set of strings when used in expressions elsewhere, you can directly use one resource as the for_each of another in situations where there is a one-to-one relationship between two sets of objects.
	In our case, we will use the azurerm_network_interface.myvmnic resource directly in azurerm_linux_virtual_machine.mylinuxvm Resource
	------------------------------------------------------------------------------------------------------	
	Step-06: Implement for_each chaining
	------------------------------------------------------------------------------------------------------
lab/16
	#cp 13 16 and do this
	vilas\terraform-tutorial\azure\steps\16

	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------
Meta argument lifecycle create_before_destroy , Prevent Destroy and Ignore_change
------------------------------------------------------------------------------------------------------


resource "azurerm_resource_group" "example" {
  # ...

  lifecycle {
    create_before_destroy = true
  }
}

Syntax and Arguments
--------------------
lifecycle block 
	contents are meta-arguments
	available for all resource blocks 
	
	arguments available "meta-argument"
		create_before_destroy, 
		prevent_destroy, 
		ignore_changes
		replace_triggered_by.

create_before_destroy (bool) - 
	For Terraform to change 
		a resource argument 
			that cannot be updated in-place 
			due to remote API limitations
		Terraform 
			destroy the existing object 
			then create a new replacement object.

create_before_destroy 
	change default behaviour
	new replacement object is created first
	prior object is destroyed after the replacement is created.

	an opt-in behavior 
		unique name 
			create before destroy can fail
		so opt in wisely.
		

prevent_destroy (bool) - 
	Terraform will 
		reject 
		throw an error 
			attempt to destroy the infrastructure object associated with the resource
	e.g. database resource created.
	Don't want to delete by mistake

ignore_changes (list of attribute names) - 
	By default, 
		Terraform detects configuration updates.
		Modifies the infrastructure

	if a resource can be modified by process outside Terraform
	for such valid updates Terraform should not modify.
	ignore_changes
		has not effect during 
			create and destroy operation
		has effect only during update

resource "aws_instance" "example" {
  # ...

  lifecycle {
    ignore_changes = [
      # Ignore changes to tags, e.g. because a management agent
      # updates these based on some ruleset managed elsewhere.
      tags,
    ]
  }
}

	ignore_changes can only ignore 
		attributes defined by the resource 
		cannot ignore 
			meta-arguments 
				including 
					lifecycle
					count

replace_triggered_by 
	(list of resource or attribute references) - 
	Added in Terraform 1.2. 
	Replaces the resource 
		when any of the referenced items change. 
		
		
		
		
References trigger replacement in the following conditions:

	If the reference is 
		multiple instances resource
			update or replace any instance 
				will trigger replacement.
		single resource instance
			update or replace that instance will trigger replacement.
		single attribute 
			change to the attribute value 
				will trigger replacement.
	
resource "aws_appautoscaling_target" "ecs_target" {
  # ...
  lifecycle {
    replace_triggered_by = [
      # Replace `aws_appautoscaling_target` each time this instance of
      # the `aws_ecs_service` is replaced.
      aws_ecs_service.svc.id
    ]
  }
}


Custom Condition Checks
	You can add precondition and postcondition blocks with a lifecycle block to specify assumptions and guarantees about how resources and data sources operate. The following examples creates a precondition that checks whether the AMI is properly configured.

resource "aws_instance" "example" {
  instance_type = "t2.micro"
  ami           = "ami-abc123"

  lifecycle {
    # The AMI ID must refer to an AMI that contains an operating system
    # for the `x86_64` architecture.
    precondition {
      condition     = data.aws_ami.example.architecture == "x86_64"
      error_message = "The selected AMI must be for the x86_64 architecture."
    }
  }
}
	Custom conditions can help capture assumptions, helping future maintainers understand the configuration design and intent. They also return useful information about errors earlier and in context, helping consumers more easily diagnose issues in their configurations.

Refer to Custom Conditions for more details.

Literal Values Only
	The lifecycle settings all affect how Terraform constructs and traverses the dependency graph. As a result, only literal values can be used because the processing happens too early for arbitrary expression evaluation.


	Step-02: Explore default resource behavior - Delete and Recreate Resource
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-03: Lifecycle Meta-Argument create_before_destroy demo
	------------------------------------------------------------------------------------------------------
lab/17	
	vilas\terraform-tutorial\azure\steps\17
	------------------------------------------------------------------------------------------------------	
	Step-04: Lifecycle Meta-Argument prevent_destroy demo
	------------------------------------------------------------------------------------------------------
lab/18		
		vilas\terraform-tutorial\azure\steps\18
	------------------------------------------------------------------------------------------------------	
	Step-05: Without Lifecycle Meta-Argument ignore_changes understand Terraform beh
	------------------------------------------------------------------------------------------------------
lab/19	
		vilas\terraform-tutorial\azure\steps\19
	------------------------------------------------------------------------------------------------------	
	Step-06: Lifecycle Meta-Argument ignore_changes demo
	------------------------------------------------------------------------------------------------------
		
	------------------------------------------------------------------------------------------------------	

Day 3
------------------------------------------------------------------------------------------------------
Terraform Input Variable
------------------------------------------------------------------------------------------------------
	Step-01: Define Terraform Input Variable
	------------------------------------------------------------------------------------------------------
	
	Input variables 
		let us customize Terraform modules 
			without altering the module's own source code
		helps share modules across different Terraform configurations
		make module 
			composable and 
			reusable.

Declare variables in the 
	root module 
		set values using 
			CLI 
			environment variables. 
declare them 
	child modules
		calling module should pass values in the module block.

Terraform supports various ways to pass input variables
	Following are those ways
	1. Input variables - Basics
	2. Provide input variables when prompted 
		during 
			plan
			apply
	3. Override default variables using 
		-var cli argument
		environment variables (TF_var_aa)
	4. Provide input variables using 
		terraform.tfvars files
	5. Input variables using structural types
	6. Provide input variables using 
		somename.tfvars
			using -var-file cli 
	7. Provide input variables using somename.auto.tfvars file
	8. Implement complex type constructors like
		list 
		map 
			in input variables
	9. Implement custom validation rules in variables
	10. Protect sensitive input variables
	11. Input variables using structural type
			tuple
			set
			
	
		



variable "image_id" {
  type = string
}

variable "availability_zone_names" {
  type    = list(string)
  default = ["us-west-1a"]
}

variable "docker_ports" {
  type = list(object({
    internal = number
    external = number
    protocol = string
  }))
  default = [
    {
      internal = 8300
      external = 8300
      protocol = "tcp"
    }
  ]
}


The label after variable 
	name for the variable
	must be unique among all variables 
		in the same module. 
	used to assign a value.

The name of a variable can be any valid identifier 
	except the following: 
		source, 
		version, 
		providers, 
		count, 
		for_each, 
		lifecycle, 
		depends_on, 
		locals.

»Arguments
	optional arguments for variable declarations:

		default
			optional
				if not specified anywhere
					prompted
		type - 
			optional
				any value can be specified
			recommend specify
				appropriate error
			can be 
				string
				number
				bool
			or complex types such as collections:
				list(<TYPE>)
				set(<TYPE>)
				map(<TYPE>)
				object({<ATTR NAME> = <TYPE>, ... })
				tuple([<TYPE>, ...])
		description 
			get's printed
		validation - 
			usually in addition to type constraints.
		sensitive - 
			
		nullable - 




Custom Validation Rules
-----------------------
variable "image_id" {
  type        = string
  description = "The id of the machine image (AMI) to use for the server."

  validation {
    condition     = length(var.image_id) > 4 && substr(var.image_id, 0, 4) == "ami-"
    error_message = "The image_id value must be a valid AMI id, starting with \"ami-\"."
  }
}

Suppressing Values in CLI Output
----------------------------------
Introduced in Terraform v0.14.0.

	sensitive 
		prevents Terraform from showing its value 

variable "user_information" {
  type = object({
    name    = string
    address = string
  })
  sensitive = true
}

Disallowing Null Input Values
-----------------------------
variable "example" {
  type     = string
  nullable = false
}


default value 
	nullable is true. 
	can pass null 
		will override default


»Using Input Variable Values
-----------------------------
Within the module that declared a variable
	value can be accessed 
		use expressions var.<NAME>
	
	
resource "aws_instance" "example" {
  instance_type = "t2.micro"
  ami           = var.image_id
}


The value assigned to a variable can only be accessed in expressions within the module where it was declared.

»Assigning Values to Root Module Variables
When variables are declared in the root module of your configuration, they can be set in a number of ways:

In a Terraform Cloud workspace.
Individually, with the -var command line option.
In variable definitions (.tfvars) files, either specified on the command line or automatically loaded.
As environment variables.
The following sections describe these options in more detail. This section does not apply to child modules, where values for input variables are instead assigned in the configuration of their parent module, as described in Modules.

»Variables on the Command Line
To specify individual variables on the command line, use the -var option when running the terraform plan and terraform apply commands:

terraform apply -var="image_id=ami-abc123"
terraform apply -var='image_id_list=["ami-abc123","ami-def456"]' -var="instance_type=t2.micro"
terraform apply -var='image_id_map={"us-east-1":"ami-abc123","us-east-2":"ami-def456"}'


The above examples show appropriate syntax for Unix-style shells, such as on Linux or macOS. For more information on shell quoting, including additional examples for Windows Command Prompt, see Input Variables on the Command Line.

You can use the -var option multiple times in a single command to set several different variables.

»Variable Definitions (.tfvars) Files
To set lots of variables, it is more convenient to specify their values in a variable definitions file (with a filename ending in either .tfvars or .tfvars.json) and then specify that file on the command line with -var-file:

terraform apply -var-file="testing.tfvars"

Note: This is how Terraform Cloud passes workspace variables to Terraform.

A variable definitions file uses the same basic syntax as Terraform language files, but consists only of variable name assignments:

image_id = "ami-abc123"
availability_zone_names = [
  "us-east-1a",
  "us-west-1c",
]

Terraform also automatically loads a number of variable definitions files if they are present:

Files named exactly terraform.tfvars or terraform.tfvars.json.
Any files with names ending in .auto.tfvars or .auto.tfvars.json.
Files whose names end with .json are parsed instead as JSON objects, with the root object properties corresponding to variable names:

{
  "image_id": "ami-abc123",
  "availability_zone_names": ["us-west-1a", "us-west-1c"]
}

»Environment Variables
As a fallback for the other ways of defining variables, Terraform searches the environment of its own process for environment variables named TF_VAR_ followed by the name of a declared variable.

This can be useful when running Terraform in automation, or when running a sequence of Terraform commands in succession with the same variables. For example, at a bash prompt on a Unix system:

$ export TF_VAR_image_id=ami-abc123
$ terraform plan
...

On operating systems where environment variable names are case-sensitive, Terraform matches the variable name exactly as given in configuration, and so the required environment variable name will usually have a mix of upper and lower case letters as in the above example.

»Complex-typed Values
When variable values are provided in a variable definitions file, you can use Terraform's usual syntax for literal expressions to assign complex-typed values, like lists and maps.

Some special rules apply to the -var command line option and to environment variables. For convenience, Terraform defaults to interpreting -var and environment variable values as literal strings, which need only shell quoting, and no special quoting for Terraform. For example, in a Unix-style shell:

$ export TF_VAR_image_id='ami-abc123'

However, if a root module variable uses a type constraint to require a complex value (list, set, map, object, or tuple), Terraform will instead attempt to parse its value using the same syntax used within variable definitions files, which requires careful attention to the string escaping rules in your shell:

$ export TF_VAR_availability_zone_names='["us-west-1b","us-west-1d"]'

For readability, and to avoid the need to worry about shell escaping, we recommend always setting complex variable values via variable definitions files. For more information on quoting and escaping for -var arguments, see Input Variables on the Command Line.

»Values for Undeclared Variables
If you have defined a variable value, but not its corresponding variable {} definition, you may get an error or warning depending on how you have provided that value.

If you provide values for undeclared variables defined as environment variables you will not get an error or warning. This is because environment variables may be declared but not used in all configurations that might be run.

If you provide values for undeclared variables defined in a file you will get a warning. This is to help in cases where you have provided a variable value meant for a variable declaration, but perhaps there is a mistake in the value definition. For example, the following configuration:

variable "moose" {
  type = string
}

And the following .tfvars file:

mosse = "Moose"

Will cause Terraform to warn you that there is no variable declared "mosse", which can help you spot this mistake.

If you use .tfvars files across multiple configurations and expect to continue to see this warning, you can use the -compact-warnings option to simplify your output.

If you provide values for undeclared variables on the command line, Terraform will error. To avoid this error, either declare a variable block for the value, or remove the variable value from your Terraform call.

»Variable Definition Precedence
The above mechanisms for setting variables can be used together in any combination. If the same variable is assigned multiple values, Terraform uses the last value it finds, overriding any previous values. Note that the same variable cannot be assigned multiple values within a single source.




Terraform loads variables in the following order
------------------------------------------------
	later sources taking precedence over earlier ones:


5	Environment variables
4	terraform.tfvars file, if present.
3	terraform.tfvars.json file, if present.
2	*.auto.tfvars or *.auto.tfvars.json files, 
		processed in lexical order of their filenames.
			relating to vocabulary of a language
	-var and -var-file options on the command line, 
1		in the order they are provided. 
	
	------------------------------------------------------------------------------------------------------	
	Step-02: Terraform Input Variable Basics Demo
	------------------------------------------------------------------------------------------------------
lab/20	
		vilas\terraform-tutorial\azure\steps\20
	------------------------------------------------------------------------------------------------------	
	Step-03: Terraform Input Variables - Assign When Prompted demo
	------------------------------------------------------------------------------------------------------
		Define some variables without default value
		terraform apply 
		terraform will prompt for those variables values
lab/21	
	try removing some default values
		vilas\terraform-tutorial\azure\steps\21
	------------------------------------------------------------------------------------------------------	
	Step-04: Terraform Input Variables - CLI Argument -var
	------------------------------------------------------------------------------------------------------
lab/21-1
	This can be done in lab/21 folder
	try providing default values using -var
terraform plan -var="resoure_group_name=demorg" -var="resoure_group_location=westus" -var="virtual_network_name=demovnet" -var="subnet_name=demosubnet" 
terraform apply -var="resoure_group_name=demorg" -var="resoure_group_location=westus" -var="virtual_network_name=demovnet" -var="subnet_name=demosubnet" 

terraform plan -var="resoure_group_name=demorg" -var="resoure_group_location=westus" -var="virtual_network_name=demovnet" -var="subnet_name=demosubnet" -out tfplan

terraform show tfplan
terraform apply tfplan
	------------------------------------------------------------------------------------------------------	
	Step-05: Terraform Input Variables - CLI Argument -var by generating a TF Plan f
	------------------------------------------------------------------------------------------------------


	------------------------------------------------------------------------------------------------------	
	Step-06: Terraform Input Variables - Override with Environment Variables
	------------------------------------------------------------------------------------------------------
lab 22	
vilas\terraform-tutorial\azure\steps\22
convention 		
	TF_VAR_variable=value
windows
	set
linux/macOS
	export

# SET Environment Variables
export TF_VAR_resoure_group_name=rgenv1
export TF_VAR_resoure_group_location=westus2
export TF_VAR_virtual_network_name=vnetenv
export TF_VAR_subnet_name=subnetenv
echo $TF_VAR_resoure_group_name, $TF_VAR_resoure_group_location, $TF_VAR_virtual_network_name, $TF_VAR_subnet_name


# Initialize Terraform
terraform init

# Validate Terraform configuration files
terraform validate

# Format Terraform configuration files
terraform fmt

# Review the terraform plan
terraform plan 
	#check the values you see. it should be based on the values in environment

terraform apply -auto-approve 

# UNSET Environment Variables after demo
unset TF_VAR_resoure_group_name
unset TF_VAR_resoure_group_location
unset TF_VAR_virtual_network_name
unset TF_VAR_subnet_name
echo $TF_VAR_resoure_group_name, $TF_VAR_resoure_group_location, $TF_VAR_virtual_network_name, $TF_VAR_subnet_name


	------------------------------------------------------------------------------------------------------	
	Step-07: Terraform Input Variables - Override with terraform.tfvars

	------------------------------------------------------------------------------------------------------
	
lab 22-1
copy the contents from 22.
copy all the contents of variable
paste it into a file called terraform.tfvars
should be in the format 
	key = "value"

Reference 	
vilas\terraform-tutorial\azure\steps\23
	22/23/24

	
	------------------------------------------------------------------------------------------------------	
	Step-08: Terraform Input Variables - anyfilename.tfvars with -var-file argument
	------------------------------------------------------------------------------------------------------

	This enables us to have env. specific variable files.
	
lab/22-2

This can be done in reference to 23 - or modified 22

vilas\terraform-tutorial\azure\steps\23
	cp terraform.tfvars dev.tfvars
	cp terraform.tfvars qa.tfvars
	rm -rf terraform.tfvars
	modify dev.tfvars 
		include dev properties - starts with dev
	modify qa.tfvars 
		include qa properties - starts with qa
	terraform plan -var-file=qa.tfvars
	terraform plan -var-file=dev.tfvars	
	------------------------------------------------------------------------------------------------------	
	Step-09: Terraform Input Variables - understand .auto.tfvars
	------------------------------------------------------------------------------------------------------
	Create a file with extension 
		.auto.tfvars.
	variables inside such files will be auto loaded 
		during terraform plan or apply

lab/23
	Reference to 23 itself
	#cp terraform.tfvars var.auto.tfvars
	mv terraform.tfvars var.auto.tfvars
	or 
	cp dev.tfvars var.auto.tfvars
	terraform plan
	------------------------------------------------------------------------------------------------------	
	Step-10: Terraform Input Variables - Review TF Configs for List Item
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-11: Terraform Input Variables - Create List Variable, Verify and CleanUp
	------------------------------------------------------------------------------------------------------
	
lab/24
	25
	
	Use reference: 
	vilas\terraform-tutorial\azure\steps\24

	Do this from 23 with terraform.tfvars
	cp 23 23a
	cd 23a
	1. Update variable.tf, add 
	
variable "virtual_network_address_space" {
  description = "Virtual Network Address Space"
  type = list(string)
  default = ["10.0.0.0/16", "10.1.0.0/16", "10.2.0.0/16"]
}
	

	2. terraform.tfvars
	add 
virtual_network_address_space = ["10.3.0.0/16", "10.4.0.0/16", "10.5.0.0/16"]

	3. Modify main.tf
	(a) modify
	
	# Create Virtual Network update address_space
resource "azurerm_virtual_network" "myvnet" {
  name                = "${var.business_unit}-${var.environment}-${var.virtual_network_name}"
  #address_space      = ["10.0.0.0/16"]
  address_space       = var.virtual_network_address_space
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
}

	(b) update subnet update virtual_network_name 
	# Create Subnet 
resource "azurerm_subnet" "mysubnet" {
  #name                 = var.subnet_name
  name                 = "${azurerm_virtual_network.myvnet.name}-${var.subnet_name}"
  resource_group_name  = azurerm_resource_group.myrg.name
  virtual_network_name = azurerm_virtual_network.myvnet.name
  address_prefixes     = ["10.3.0.0/24"]
}



Reference List values individually
----------------------------------
	update main.tf, update address to one of values
	
resource "azurerm_virtual_network" "myvnet" {
  name                = "${var.business_unit}-${var.environment}-${var.virtual_network_name}"
  #address_space      = ["10.0.0.0/16"]
  #address_space       = var.virtual_network_address_space
  address_space       = [var.virtual_network_address_space[0]]
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
}	
	------------------------------------------------------------------------------------------------------	
	Step-12: Terraform Input Variables - Review TF Configs for Maps Item
	------------------------------------------------------------------------------------------------------
lab/24-1	
	26
	helps to define a map/dictionary
	e.g. {name = "Vilas", age = 44}.
	
	cp 24 24a
	cd 24a

	(a) Add couple of variables like 

#Public IP SKU
variable "public_ip_sku" {
  description = "Azure Public IP Address SKU"
  type = map(string)
  default = {
    "eastus" = "Basic"
    "eastus2" = "Standard" 
  }
}

#Common Tags
variable "common_tags" {
  description = "Common Tags for Azure Resources"
  type = map(string)
  default = {
    "CLITool" = "Terraform"
    "Tag1" = "Azure"
  } 
}	
	
	(b) Update main.tf - modify mypublicip
	add 
	
	sku = var.public_ip_sku["eastus"]
	tags = var.common_tags
	
	N.B: tags = var.common_tags can be added to any other resources also.
	common_tags will not be auto applied. 
	
	terraform init
	terraform plan
		verify the output

	(c) Add tags to few more resources and execute
	terraform plan
		verify the output


	
	N.B: 
If the map's key 
	starts with a number (inside a string)  
	e.g. "1-development", 
	use colon syntax : instead of =
	like below
	
variable "my_env_names" {
  type = map(string)
  default = {
    "1-development": "dev-apps"
    "2-staging": "staging-apps"
    "3-production": "prod-apps"
  }
}
	
	------------------------------------------------------------------------------------------------------	
	Step-13: Terraform Input Variables - lookup function
	------------------------------------------------------------------------------------------------------

lab/24-2
	continue from above lab

	(d) 
	terraform console
	lookup (map, key, defaultValue) #=> equivalent to map.get(key)
	> lookup({a="ay", b="bee"}, "a", "what?")
	"ay"
	> lookup({a="ay", b="bee"}, "b", "what?")
	"bee"
	> lookup({a="ay", b="bee"}, "c", "what?")
	"what?"
	
	# Terraform lookup() Function with our map
	lookup({"eastus"="Basic", "eastus2"="Standard"},"eastus", "Basic")
	lookup({"eastus"="Basic", "eastus2"="Standard"},"eastus2", "Basic")
	lookup({"eastus"="Basic", "eastus2"="Standard"},"myeast", "Basic")
	exit
	
	(e)
	Modify mypublicip in main.tf
	comment sku and modify it with lookup as below
	#sku = var.public_ip_sku["eastus"]
	sku = lookup(var.public_ip_sku, var.resoure_group_location)


	------------------------------------------------------------------------------------------------------	
	Step-14: Terraform Input Variables - Create Map Variables, Verify and CleanUp
	------------------------------------------------------------------------------------------------------
	completed above

	------------------------------------------------------------------------------------------------------	
	Step-15: Terraform Functions: Length, Substring, Lower, Upper and Contains
	------------------------------------------------------------------------------------------------------
	Length
		find length
		can work with 
			String
			List
			Map
	Substring
		works with 
			string only
	Lower
		supports string only
	Upper
		supports string only
	Contains
		supports 
			list 
			tupule 
			set
			not supported : map
lab/24-3
	terraform console
	length("hi")
		length("hello")
		length(["a", "b", "c"]) 
		length({"key" = "value"}) 
		length({"key1" = "value1", "key2" = "value2" }) 

	syntax	
		substr(string, offset, length)
	substr("vilas varghese", 1, 4)
	substr("vilas varghese", 0, 6)
	substr("vilas varghese", 0, 1)
	substr("vilas varghese", 0, 0)
	substr("vilas varghese", 0, 10)
		
	syntax: 
		contains(list, value)
	contains(["a", "b", "c"], "a")
	contains(["a", "b", "c"], "d")
	contains(["eastus", "eastus2"], "westus2")

		
	# Test lower() function
	Template: lower("STRING")
	lower("VILAS VARGHESE")
	lower("TERRAFORM")

	# Test upper() function
	Template: lower("string")
	upper("vilas varghese")
	upper("terrform")
	
	------------------------------------------------------------------------------------------------------	
	Step-16: Terraform Input Variables - Validation Rules with OR and contains 
	------------------------------------------------------------------------------------------------------
	Values for variables can come from various sources
	Ensure that the value a variable picks up is valid.
		enforce validation 
	Validation Rules has two parts
		condition
		error_message

	condition: 
		define expression 
		evaluate the Input Variable. 
		Must return 
			true/false .
	error_message: 
		Defines error message 
		displayed when condition returns false Must end with 
			period 
		or 
			question mark

	------------------------------------------------------------------------------------------------------	
	Step-17: Terraform Input Variables - Validation Rules with regex
	------------------------------------------------------------------------------------------------------
	
lab/24-4

	Modify resoure_group_location in main.tf as 
variable "resoure_group_location" {
  description = "Resource Group Location"
  type = string
  default = "eastus"
  validation {
    condition  = var.resoure_group_location == "eastus" || var.resoure_group_location == "eastus2"
    #condition = contains(["eastus", "eastus2"], lower(var.resoure_group_location))
    error_message = "We only allow Resources to be created in eastus or eastus2 Locations."
  }  
}
	
	Modify resoure_group_location in terraform.tfvars and execute
	terraform plan 
		values possible
			eastus
			eastus2
			westus
			southindia
			
	
lab/24-5

Terraform regex() and can() Function

	can 
		can evaluates an expression 
		returns a boolean value 
			true if expression produced a result false if errors.


# Go to Terraform Console
terraform console

# Test regex() function
Template: regex(pattern, string)
### TRUE CASES
regex("india$", "westindia")
regex("india$", "southindia")
can(regex("india$", "westindia"))
can(regex("india$", "southindia"))

### FAILURE CASES
regex("india$", "eastus")
can(regex("india$", "eastus"))


	modify resoure_group_location in variables.tf as 

variable "resoure_group_location" {
  description = "Resource Group Location"
  type = string
  default = "eastus"
  validation {
    condition = can(regex("india$", var.resoure_group_location))
    error_message = "We only allow Resources to be created in westindia and southindia locations."
  }  
}

	modify resource values in terraform.tfvars
	execute terraform plan
	------------------------------------------------------------------------------------------------------	
	Step-18: Terraform Input Variables - Sensitive Introduction
	------------------------------------------------------------------------------------------------------
	28
	
	confidential variables 
		if used in plain text 
			may be present in 
				env. variables
				command line history
	e.g. 
		export TF_VAR_db_username=admin TF_VAR_db_password=adifferentpassword


	sensitive in Terraform allows us to 
		use as usual.
	Terraform will mask these values 
		in command output and 
		log files
		raise an error 
			if it detects that they will be exposed in other ways.
	Important Note-1: 
		Never check-in secrets.tfvars 
			to git repositories
	Important Note-2: 
		Terraform state file 
			contains values for these sensitive variables terraform.tfstate. 
			You must keep your state file secure to avoid exposing this data.


lab/25
	

	------------------------------------------------------------------------------------------------------	
	Step-19: Terraform Input Variables - Define Sensitive, bool and Number Variables
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-20: Terraform Input Variables - Create Azure MySQL Server Resources
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-21: Terraform Input Variables - Create Azure MySQL DB, Test and CleanUp
	------------------------------------------------------------------------------------------------------
lab/25	
	
	vilas\terraform-tutorial\azure\steps\25
	
	terraform plan -var-file="secrets.tfvars"
	terraform apply -var-file="secrets.tfvars"
	grep administrator_login terraform.tfstate
	grep administrator_login_password terraform.tfstate 

	connect using cloud shell
	no ssh required
	Find the cloud shell ip using 
		curl -s checkip.dyndns.org | sed -e 's/.*Current IP Address: //' -e 's/<.*$//'
	Go to Settings -> Connection Security -> Add Client IP (Add your Public IP) -> Click on Save
	
	
	mysql --version
	mysql -h <Azure DB Server Name> -u <user@server> -p 
	server name: find it from azure portal
	username and pwd is what you gave. username should be like user@server.
	mysql -h it-dev-mydb201.mysql.database.azure.com  -u vilasadmin@it-dev-mydb201 -p

	show schemas;

	terraform destroy #below exercise is not compatible with this.
	also check variable precidence
	------------------------------------------------------------------------------------------------------	
	Step-22: Terraform Input Variables - Structural Type Object Introduction
	------------------------------------------------------------------------------------------------------
	Structural types 
		like structure in c
		allow multiple values of different types 
			to be grouped together as a single value.
	(mandatory) requires a data schema to be defined 
		for the Input Variables type 
		Terraform knows what a valid value is.
	use type= object(): 
		A collection of values each with their own type.

e.g.
# Sample object()
variable "os_configs" {
  type = object({
	location       = string
	size           = string
	instance_count = number
  })
}
	
		29

lab/26
	Enable Threat Detection Policy in Azure MySQL Database.
	For threat_detection_policy block 
		implement Input Variable Structural Type object()
	
	# 11. Azure MySQL DB Threat Detection Policy (Variable Type: Object)
	(a)cp 25 26
	(b) cd 26
	(c) Update variables.tf
	
variable "tdpolicy" {
    description = "Azure MySQL DB Threat Detection Policy"
    type = object({
        enabled = bool
        retention_days = number
        email_account_admins = bool
        email_addresses = list(string)
  })
}
	

	(d)
	Threat Detection Policy 
		not supported for Basic Tier
	Update main.tf
	#sku_name   = "B_Gen5_2" # Basic Tier
	sku_name 	= "GP_Gen5_2"   # General Purpose Tier

	(e)
	Add below in main.tf inside azurerm_mysql_server block
resource "azurerm_mysql_server" "mysqlserver" {
.
.
.
.
	threat_detection_policy {
		enabled = true
		retention_days = 10
		email_account_admins = true
		email_addresses = [ "vilas.varghese@gmail.com", "vilas_varghese@yahoo.com" ]
	}
}

alternatively it could be as follows also...
# With Structural Type object() defined in Variables
  threat_detection_policy {
    enabled = var.tdpolicy.enabled
    retention_days = var.tdpolicy.retention_days
    email_account_admins = var.tdpolicy.email_account_admins
    email_addresses = var.tdpolicy.email_addresses
}

	(f)
	Update terraform.tfvars
# DB Variables
db_name = "mydb101"
db_storage_mb = 5120
db_auto_grow_enabled = true
tdpolicy = {
    enabled = true
    retention_days = 10
    email_account_admins = true
    email_addresses = [ "vilas.varghese@gmail.com", "vilas_varghese@yahoo.com" ]
}


Go to Azure MySQL Database -> it-dev-mydb101 -> Security -> Azure Defender for MySQL

	(g)
	terraform plan -var-file="secrets.tfvars"
		#check the output
	terraform apply -var-file="secrets.tfvars"
	terraform destroy -var-file="secrets.tfvars"
	------------------------------------------------------------------------------------------------------	
	Step-23: Terraform Input Variables - Create TF Configs of ST Object
	------------------------------------------------------------------------------------------------------
		
	covered above	
	------------------------------------------------------------------------------------------------------	
	Step-24: Terraform Input Variables - Execute TF Commands, Verify and CleanUp ST
	------------------------------------------------------------------------------------------------------

	covered above
	refer the input from variable section.
	------------------------------------------------------------------------------------------------------	
	Step-25: Terraform Input Variables - Create TF Configs for ST Tuple



	tuple(): 
		A sequence of values 
			each with their own type.
		List of uneven elements
	
lab/27	
	vilas\terraform-tutorial\azure\steps\27\
	30
	------------------------------------------------------------------------------------------------------


	(a)
	cp 25 27
	cd 27

	(b)
Update variables.tf	
variable "tdpolicy" {
    description = "Azure MySQL DB Threat Detection Policy"
    type = tuple([bool, number, bool, list(string)])
}

	(c)
Update main.tf
 #sku_name   = "B_Gen5_2" # Basic Tier
 sku_name = "GP_Gen5_2"   # General Purpose Tier


	(d)
	Add below in main.tf inside azurerm_mysql_server block
resource "azurerm_mysql_server" "mysqlserver" {
.
.
.
.
	
  threat_detection_policy {
    enabled = var.tdpolicy[0]
    retention_days = var.tdpolicy[1]
    email_account_admins = var.tdpolicy[2]
    email_addresses = var.tdpolicy[3]
  }

	(e)

Update terraform.tfvars
tdpolicy = [true, 10, true, [ "vilas.varghese@gmail.com", "vilas_varghese@yahoo.com" ]]



	(f)
	terraform plan -var-file="secrets.tfvars"
		#check the output
	terraform apply -var-file="secrets.tfvars"
Go to Azure MySQL Database -> it-dev-mydb101 -> Security -> Azure Defender for MySQL

	terraform destroy -var-file="secrets.tfvars"
	------------------------------------------------------------------------------------------------------	
	Step-26: Terraform Input Variables - Run TF Plan and Verify tuple var value repl
	------------------------------------------------------------------------------------------------------
		should be there
	------------------------------------------------------------------------------------------------------	
	Step-27: Terraform Input Variables - Introduction to Collection Type set
	------------------------------------------------------------------------------------------------------
		
	31	

	------------------------------------------------------------------------------------------------------	
	Step-28: Terraform Input Variables - Review TFConfigs for CT Set
	------------------------------------------------------------------------------------------------------
	
	Sets 
		do not support element ordering
		traversing sets 
			can yield different order 
				each time 
			elements can not be accessed in a targeted way.
		contain unique elements 
			repeated exactly once
			duplicate elements are ignored
		Declaring a set 
			similar to declaring a list
			only difference in type:

lab/28
	vilas\terraform-tutorial\azure\steps\28
	------------------------------------------------------------------------------------------------------	
	Step-29: Terraform Input Variables - Execute TF Commands, Verify and CleanUp CT
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------
Terraform Output Values
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/values/outputs

	Step-00: Output Values Introduction
	Simple
		Root module 
			use output to print values in CLI output
				terraform apply
				e.g. vm: dns name, public ip.
	Advanced
		Child module	
			expose [few] resource attributes
				to a parent module
		In remote state
			root module o/p 
				accessed by other modules	
					use terraform_remote_state data source

	Output's
		documentation 
			argument references
			attributes references
	output 
		top level block in terraform
		like variables
		can help to access
			argument and at
	
	
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-01: Create Basic Output Values and Review TF Configs
	------------------------------------------------------------------------------------------------------
lab/29
	vilas\terraform-tutorial\azure\steps\29
	
	# Terraform Output Commands
terraform output
terraform output resource_group_id
terraform output virtual_network_name




Suppressing Sensitive Values in Output
--------------------------------------
We can redact the sensitive outputs 
	use sensitve = true 
		in output block
	value would be masked in terraform output/apply
	but can see original value in terraform output
	----------------------------------------------
	
	terraform output command 
		fetch values from terraform.tfstate files

Add sensitve = true for output virtual_network_name
# 2. Output Values - Virtual Network
output "virtual_network_name" {
  description = "Virutal Network Name"
  value = azurerm_virtual_network.myvnet.name 
  sensitive = true
}


# Terraform Apply
terraform apply -auto-approve
Observation: 
1. You should see the value as sensitive

See original value: Query using terraform output
terraform output virtual_network_name
Observation: 
1. You should get non-redacted original value from terraform.tfstate file

Generate machine-readable output
terraform output -json


	------------------------------------------------------------------------------------------------------	
	Step-02: Execute TF Commands, Verify and learn about "terraform output" command
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-03: Output Values with Sensitive flag and also "terraform output -json"
	------------------------------------------------------------------------------------------------------
	covered above
	Another example
	
	------------------------------------------------------------------------------------------------------	
	Step-04: Output Values with Meta-Argument count and Splat Expression
	------------------------------------------------------------------------------------------------------
	splat can work only in list
	for maps, 
		use resource meta argument for_each 

	count.index is not available in a seperate block like output
lab/30
	vilas\terraform-tutorial\azure\steps\31
	33
	------------------------------------------------------------------------------------------------------	
	Step-05: Output Values with Meta-Argument for_each and For Expression
	------------------------------------------------------------------------------------------------------
lab/32		
lab/31		
	vilas\terraform-tutorial\azure\steps\31
	following also covered in this.
	
	------------------------------------------------------------------------------------------------------	
	Step-06: Create List Outputs
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-07: Create Map Outputs and use key and values functions
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
Terraform Local values
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/values/locals

	DRY principle
	Local values 
		assigns a name to an expression 
		refer to the expression using name 
		don't repeat expression
		like a reference to a function
		refer it as local.<NAME>
		easy to understand, manage and maintain

toplevel block local
local {
	name = "vilas"#the value here could be an expression azurerm_resourece_group.name
	owner = "my project"
}

local {
	#Common tags to be assigned to all resources
	#will not automatically assign. but makes it easy
	common_tags = {
		name = "vilas"
		owner = "my project"
	}
}


	
Create Local Values Terraform Config
------------------------------------------------------------------------------------------------------
lab/33
	vilas\terraform-tutorial\azure\steps\33
	35

------------------------------------------------------------------------------------------------------

Terraform Condtional Expression
------------------------------------------------------------------------------------------------------


	Step-01: Terraform Conditional Expressions Introduction and Create TF Configs
	------------------------------------------------------------------------------------------------------
	select a configuration based on condition.
	variables doesn't support conditional expressions.
	supported in 
		local values 
		resources.
	36
	------------------------------------------------------------------------------------------------------	
	AZHCTA-36-02-TFCE-Conditional-Expressions-Execute-TFCommands-Verify-CleanUp
	------------------------------------------------------------------------------------------------------


lab/34

vilas\terraform-tutorial\azure\steps\34
Jump to step 5
or

Modify existing 
	vilas\terraform-tutorial\azure\steps\33

Reference
# Example-1
condition ? true_val : false_val
# Example-2
var.a != "" ? var.a : "default-a"


1. Declare two more in variables.tf
Select one based on condition
# 6. Virtual Network Address - Dev
variable "vnet_address_space_dev" {
  description = "Virtual Network Address Space for Dev Environment"
  type = list(string)
  default = ["10.0.0.0/16"]
}

# 7. Virtual Network Address - 
variable "vnet_address_space_all" {
  description = "Virtual Network Address Space for All Environment except Dev"
  type = list(string)
  default = ["10.1.0.0/16", "10.2.0.0/16", "10.3.0.0/16"]
}

2. Update local.tf - update condition  vnet_address_space = ? a : b

locals {
  # Use-case-1: Shorten the names for more readability
  rg_name = "${var.business_unit}-${var.environment}-${var.resoure_group_name}"
  vnet_name = "${var.business_unit}-${var.environment}-${var.virtual_network_name}"

  # Use-case-2: Common tags to be assigned to all resources
  service_name = "Demo Services"
  owner = "Vilas Varghese"
  common_tags = {
    Service = local.service_name
    Owner   = local.owner
  }

  # Use-case-3: Terraform Conditional Expressions
  # We will learn this when we are dealing with Conditional Expressions
  # The expressions assigned to local value names can either be simple constants or can be more complex expressions that transform or combine values from elsewhere in the module.
  # With Equals (==)
  vnet_address_space = (var.environment == "dev" ? var.vnet_address_space_dev : var.vnet_address_space_all)
  # With Not Equals (!=)
  #vnet_address_space = (var.environment != "dev" ? var.vnet_address_space_all : var.vnet_address_space_dev)
}


3. Update main.tf - update 
	address_space = local.value
	
# in Virtual Network
resource "azurerm_virtual_network" "myvnet" {
  #name                = "${var.business_unit}-${var.environment}-${var.virtual_network_name}"
  name                = local.vnet_name
  #address_space       = ["10.0.0.0/16"]
  address_space       = local.vnet_address_space
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
  tags = local.common_tags
}

4. Add conditional count as below in main.tf

# Create Virtual Network - Conditional Expressions in a Resource Demo
resource "azurerm_virtual_network" "myvnet2" {
  #count = 2
  count = var.environment == "dev" ? 1 : 5
  name                = "${var.business_unit}-${var.environment}-${var.virtual_network_name}-${count.index}"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name
  tags = local.common_tags
}


5. Modify variable environment in variables.tf with dev/any other value and run
terraform plan
#watch how many are getting created.


	------------------------------------------------------------------------------------------------------	
	AZHCTA-36-03-TFCE-Conditional-Expressions-in-a-Resource-Demo
	------------------------------------------------------------------------------------------------------
		
			covered above
	------------------------------------------------------------------------------------------------------	

------------------------------------------------------------------------------------------------------
Terraform Data Source
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/data-sources
	37

	Step-02: Create Datasource for Resource Group Resource
	
	
	Data sources
		fetch or compute data
			use it in Terraform
			e.g. AMI 
			
		can access data outside Terraform
			by 
				cloud sources
				another Terraform configuration (module)
		accessed using special resource
			called data resource
			use data block
		
e.g.
data block: top level block 
data "azurerm_subscription" "current" {
	
}
				
		a data resource is associated to a 
			single data source
			datasource: 
				determine kind of object(s)
					reads
					what query arguments are available
		data resource
			similar dependency resolution behaviour as 
				defined or managed resources
			use depends_on meta argument
				reading data source delayed till update to dependencies are done.
			use provider argument 
				to work with a certain provider
			use count and  for_each 
				to execute multiple times
			lifecycle meta arguments
				not supported
				but reserved for future
		
	
Search for azurerm_resource_group in terraform documentation
	find the documentation under 'data source'

	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-03: Create Datasource for Virtual Network
	------------------------------------------------------------------------------------------------------
lab/35
	vilas\terraform-tutorial\azure\steps\35
	37

	
	------------------------------------------------------------------------------------------------------	
	Step-04: Create Datasource for Azure Subscription
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------
Terraform Remote State and Locking
------------------------------------------------------------------------------------------------------
	
	Backend 
		store 
			state 
		and 
			lock (api for locking)
	Both state and lock can be stored in 
		azure storage account
		aws s3 
		
			
	
	https://www.terraform.io/language/state/locking
	38

On the portal 
----------------
1: Create Resource Group
Go to Resource Groups -> Add
Resource Group: terraform-storage-rg
Region: East US
Click on Review + Create
Click on Create
	
2: Create Azure Storage Account
Go to Storage Accounts -> Add
Resource Group: terraform-storage-rg
Storage Account Name: terraformstate<vilas1> (THIS NAME SHOULD BE UNIQUE ACROSS AZURE CLOUD)
Region: East US
Performance: Standard
Redundancy: Geo-Redundant Storage (GRS)
In Data Protection, check the option Enable versioning for blobs
REST ALL leave to defaults
Click on Review + Create
Click on Create


3: Create Container in Azure Storage Account
Go to Storage Account -> terraformstate201 -> Containers -> +Container
Name: tfstatefiles
Public Access Level: Private (no anonymous access)
Click on Create

lab/36
	vilas\terraform-tutorial\azure\steps\36
	cp ../11/ssh-keys .
	38
	
1.	Add remote state block in terraform block 
	Refer provider.tf
	# Terraform State Storage to Azure Storage Container
  backend "azurerm" {
    resource_group_name   = "terraform-storage-rg"
    storage_account_name  = "terraformstate201"
    container_name        = "tfstatefiles"
    key                   = "terraform.tfstate"
  } 

Review all other files.

terraform init
	Observation: 
	1. Review below message
	2. Verify the Azure Storage Account and you should see terraform.tfstate file created
	## Sample CLI Output
	Initializing the backend...
	Successfully configured the backend "azurerm"! Terraform will automatically
	use this backend unless the backend configuration changes.

terraform validate

# Review the terraform plan
terraform plan 
	Observation:
	1. Acquiring state lock. This may take a few moments...

# Create Resources 
terraform apply -auto-approve
	# Verify Azure Storage Account for terraform.tfstate file
	Observation: 
	1. Finally at this point you should see the terraform.tfstate file in Azure Storage Account. 

# Access Application
http://<Public-IP>

Destroy after completing next exercise

	Step-02: Create Azure Storage Account and Container
	------------------------------------------------------------------------------------------------------

	

	Check the azure cloud storage and the container there
	
	
	Now uncomment tags in local.tf
common_tags = {
    Service = local.service_name
    Owner   = local.owner
    Tag = "demo-tag1"  # Uncomment during step-05
}

terraform plan 

# Create Resources 
terraform apply -auto-approve

# Verify terraform.tfstate file in Azure Storage Account
Observation: 
1. New version of terraform.tfstate file will be created
2. Understand about Terraform State Locking 
3. terraform.tfsate file should be in "leased" state which means no one can apply changes using terraform to Azure Resources.
4. Once the changes are completed "terraform apply", Lease State should be in "Available" state. 


terraform destroy
	------------------------------------------------------------------------------------------------------	
	Step-03: Create TF Backend Block with Azure Storage Account and Review TF Config
	------------------------------------------------------------------------------------------------------
	
	
	
	------------------------------------------------------------------------------------------------------	
	Step-04: Execute TF Commands, Verify Remote State Storage and Locking Features
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-05: Understand Azure Storage Account TF State File Versioning and CleanUp
	------------------------------------------------------------------------------------------------------


	------------------------------------------------------------------------------------------------------	

Day 4
------------------------------------------------------------------------------------------------------
Terraform state command
------------------------------------------------------------------------------------------------------
	
	Terraform Commands
		terraform show
		terraform state
		terraform force-unlock
		terraform taint
		terraform untaint
		terraform apply -target command
	
	state command reference
		https://www.terraform.io/docs/cli/commands/state/index.html
	Inspect state
		https://www.terraform.io/docs/cli/state/inspect.html
	State
		https://www.terraform.io/docs/language/state/index.html
	Manupulating state
		https://www.terraform.io/docs/cli/state/index.html
	Other helpful docs
		https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform
	
Terraform Show Command 
	provide human-readable output from 
		a state or 
		plan file.
	why show?
		inspect a plan 
			planned operations are expected, 
		or 
		inspect the current state as


	
	
	Step-01: Terraform Show Command to read Terraform Plan Files
	------------------------------------------------------------------------------------------------------
lab/37
	vilas\terraform-tutorial\azure\steps\37

	# Initialize Terraform
	terraform init

	# Terraform Validate
	terraform validate

	# Create Plan 
	terraform plan
	terraform plan -out=v1plan.out

	# Read the plan 
	terraform show v1plan.out
	terraform show  # Nothing as terraform.tfstate file not created yet
	
	# Read the plan in json format (Unformatted / Not Readable)
	terraform show -json v1plan.out 

	# Install jq (for mac and fine tuned json output)
	brew install jq
	terraform show -json v1plan.out | jq	

	N.B: Don't execute apply
	------------------------------------------------------------------------------------------------------	
	Step-02: Terraform Show Command to read Terraform State Files
	------------------------------------------------------------------------------------------------------
		
# Terraform Show
terraform show
	we haven't executed apply yet
Observation: 
	1. AWS provider 
		"No State" 
			we haven't created resources yet 
			no state file in current working directory
	2. For Azure Provider
		empty response. 

# Create Resources
#terraform apply -auto-approve
terraform apply v1plan.out

# Terraform Show 
terraform show
Observation: It should display the state file



continue without destroy


	------------------------------------------------------------------------------------------------------	
	Step-03: Terraform State List and Show Commands
	------------------------------------------------------------------------------------------------------
	used for Inspecting Terraform State
	terraform state list: 
		list resources within Terraform state.
	terraform state show: 
		view attributes of one resource 
			from the Terraform state.
	
	# List Resources from Terraform State
	terraform state list

	# Show the attributes of a single resource from Terraform State
	
	terraform state show data.azurerm_subscription.current
	terraform state show azurerm_virtual_network.myvnet
	terraform state show azurerm_resource_group.myrg

	------------------------------------------------------------------------------------------------------	
	Step-04: Terraform State mv command
	------------------------------------------------------------------------------------------------------

	Moving Resources
		https://www.terraform.io/docs/cli/state/move.html


	Use this command to modify the name of a resource without any change in cloud.
	
lab/38
This lab can be performed with 37 itself.
	For reference check 38 - main.tf file after the commands have executed.
	
terraform state mv
	To move Terraform Resources
	move an item 
		to destination address.
		new state file
			rename state file
	N.B: Very dangerous command
	Results unpredictable 
		if concept are not clear 
			understand 
				desired state and 
				current state.
	Validate before using in production.
	
# Terraform List Resources
terraform state list

# Terraform State Move Resources to different name
terraform state mv -dry-run azurerm_virtual_network.myvnet azurerm_virtual_network.myvnet-new
terraform state mv azurerm_virtual_network.myvnet azurerm_virtual_network.myvnet-new
terraform state list
ls -lrta # To verify state file backup

By default,
	a backup of your state file is written to terraform. 
		tfstate.backup 
	if state file is 
		lost 
	or 
		corrupted 
			recover. 
	
Observation: 
1) renamed the name of 
	"myvnet" in state file to 
		"myvnet-new". 
2) terraform plan 
	what happens in next run of terraform plan and apply?
-----------------------------
# WRONG APPROACH 
-----------------------------
	Doing TERRAFORM PLAN AND APPLY 
		AFTER ABOVE CHANGE terraform state mv CHANGE
# Correct Approach: 
	UPDATE EQUIVALENT RESOURCE FIRST before next plan and apply. 

# Terraform Plan
terraform plan
Observation: It will show "Plan: 1 to add, 0 to change, 1 to destroy."
1 to add: New VNET will be added
1 to destroy: Old VNET will be destroyed

 # azurerm_virtual_network.myvnet will be created
  + resource "azurerm_virtual_network" "myvnet" {

 # azurerm_virtual_network.myvnet-new will be destroyed
  - resource "azurerm_virtual_network" "myvnet-new" {



DON'T DO TERRAFORM APPLY 
-----------------------------
	because it shows make changes. 
	Nothing changed other than state file 
		local naming of a resource. 
	There should be no real cloud environment change due to this


#Now modify the main.tf - uncomment and comment as required.

Now run terraform plan 
	should see no changes to Infra

# Terraform Plan
terraform plan
Observation: 
1) Message-1: 
	No changes. Infrastructure is up-to-date

# Sample Message: 
Your configuration already matches the changes detected above. If you'd like to update the
Terraform state to match, create and apply a refresh-only plan:
  terraform apply -refresh-only

# Terraform Apply (refresh-only)
terraform apply -refresh-only
	------------------------------------------------------------------------------------------------------	
	Step-05: Terraform State rm command and replace-provider command
	------------------------------------------------------------------------------------------------------
	
	remove provider and change config. to point to a local repo. like JFrog artifactory

A "Terraform Moving Resources"
 
terraform state rm command 
	remove items from the Terraform state.
	remove 
		single resource, 
		single instances of a resource, 
		entire modules, and more.

# Terraform List Resources
terraform state list

# Remove Resources from Terraform State
terraform state rm -dry-run azurerm_virtual_network.myvnet-new
terraform state rm azurerm_virtual_network.myvnet-new
Observation: 
1) Removes it from terraform.tfstate file
	remains in cloud
	remains in configuration

# Terraform Plan
terraform plan
Observation: 
	resource is not in state file 
	but 
		present in your terraform manifests 
		(.tf - DESIRED STATE). 
		Do you want to re-create it?

apply will 	
	re-create new Virtual Network 
	exclude one created earlier and running

Make a  Choice
-------------
Choice-1: 
	You want 
		resource to be running on cloud 
		but should not be managed by terraform. 
		Then remove its references in terraform manifests(DESIRED STATE). 
		So that the one running in Azure cloud (current infra) this instance will be independent of terraform. 
Choice-2: 
	You want a new resource to be created without deleting other one 
	(non-terraform managed resource now in current state). 
	Run terraform plan and apply
	any other reason?

PRIMARY REASON for this is command 
	respective resource need to be removed from as terraform managed
	start using another resource created directly. 

# Run Terraform Plan (I made choice-2)
terraform plan # NO ERROR 
terraform apply -auto-approve # UNIQUE CONSTRAINT ERROR FOR VNET NAME


# Error Message
- YOU WILL get a unique resource name on Azure for Virtual Network under this resource group error when you run "terraform apply". 
- Change the Terraform Manifests Virtual Network name to different one and test
│ Error: A resource with the ID "/subscriptions/82808767-144c-4c66-a320-b30791668b0a/resourceGroups/hr-dev-myrg/providers/Microsoft.Network/virtualNetworks/hr-dev-myvnet" already exists - to be managed via Terraform this resource needs to be imported into the State. Please see the resource documentation for "azurerm_virtual_network" for more information.

# Update c5-virtual-network.tf
Before: name = local.vnet_name
After: name = "${local.vnet_name}-2"

# Update c7-datasource-virtual-network.tf
Before: name = local.vnet_name
After: name = "${local.vnet_name}-2"

# Run Terraform Plan Again
terraform plan
terraform plan -out=v2plan.out

# Run Terraform Apply
terraform apply v2plan.out

# Verify in Azure Portal
1. In Azure Portal, you should see two Virtual Networks in a Resource Group
- hr-dev-myvnet: Not managed by Terraform 
- hr-dev-myvnet-2: Managed by Terraform

	------------------------------------------------------------------------------------------------------	
State replace provider
	Theory
	https://www.terraform.io/cli/commands/state/replace-provider

	used to point to a local jfrog/nexus
	------------------------------------------------------------------------------------------------------	
	Step-06: Terraform State Push Pull and Force-Unlock Commands
	------------------------------------------------------------------------------------------------------

	
	Force-Unlock
		azure storage account doesn't support this feature
		works in aws dynamo db.
		
		
Setup for remote state in azure storage 
	A "Terraform Disaster Recovery" command

terraform state pull:
	copy paste the content to local.
		file: terraform.tfstate 
			remote name may be different


terraform state push:
	force upload local state file to remote state.

# Verify if any local state files
ls -lrta terraform.tfstate 

# Terraform state pull
terraform state pull # CLI will output the terraform state

# Create new state file locally
vi terraform.tfstate
COPY ABOVE "terraform state pull" output to this file

# Make a note of Current Remote State file last updated and Version ID (From Azure Storage Container )
LAST MODIFIED	6/11/2021, 12:50:22 PM
CREATION TIME	6/11/2021, 12:50:21 PM
VERSION ID	2021-06-11T07:20:22.2334683Z

#N.B: This command is not working. This is not a critical feature.
#It is better avoid learning in reality.
# Terraform State Push
terraform state push # watch the command output.
terraform state push terraform.tfstate

# Verify new State file copied in Azure Storage Container
LAST MODIFIED	6/11/2021, 12:57:23 PM
CREATION TIME	6/11/2021, 12:50:21 PM
VERSION ID	2021-06-11T07:27:23.0504198Z


-----------------------------------------
Step-06: Terraform force-unlock command
-----------------------------------------
	A "Terraform Disaster Recovery" 
	Manually unlock the state for the defined configuration.
	will not modify 
		infrastructure on cloud
		my configuration.
	
	behavior of this lock depends on 
		backend (if supports) being used.
	Important Note: Local state files cannot be unlocked by another process.
	# Manually Unlock the State
	terraform force-unlock LOCK_ID	
		
	------------------------------------------------------------------------------------------------------	
	Step-07: Terraform Taint and Untaint Commands
	------------------------------------------------------------------------------------------------------

	Disaster recovery
		https://www.terraform.io/docs/cli/state/recover.html
	Taint
		https://www.terraform.io/docs/cli/state/taint.html


	A "Terraform Forcing Re-creation" command
	
When a resource declaration is modified
	Terraform attempts in-place-update  
	(many changes 
		destruction and re-creation, 
		usually due to upstream API limitations).
	
	Sometimes such changes can be in corrupted state
		tainted state

terraform taint: 
	marks a resource as tainted, 
	force it 
		destroyed and recreated on the next apply.
		
terraform untaint:
	unmarks a resource as tainted, 
	restore it as the primary instance in the state.
	will not delete on apply
	will not modify infrastructure
	but modify the state file 
		unmark a resource as tainted.

# List Resources from state
terraform state list

# Taint a Resource
terraform taint <RESOURCE_NAME_IN_TERRAFORM_LOCALLY>
terraform taint azurerm_virtual_network.myvnet-new

# Terraform Plan
terraform plan
Observation: 
Message: "-/+ destroy and then create replacement"
Plan: 1 to add, 0 to change, 1 to destroy.

# Untaint a Resource
terraform untaint <RESOURCE_NAME_IN_TERRAFORM_LOCALLY>
terraform untaint azurerm_virtual_network.myvnet-new

# Terraform Plan
terraform plan
Observation: 
Message: "No changes. Your infrastructure matches the configuration."

	------------------------------------------------------------------------------------------------------	
	Step-08: Terraform Plan and Apply - "-target" option for Resource Targeting
	------------------------------------------------------------------------------------------------------
	
	-target option 
		focus Terraform's attention on a subset of resources.

Terraform Resource Targeting
-----------------------------
	for exceptional circumstances
	e.g. 
		recover from mistakes 
	or 
		work around Terraform limitations.

recommendation
	don't -target for routine operations
	can lead to undetected configuration drift and 
	confusion 
		state of resources relates to configuration.


Instead 
	break large configurations 
		into smaller configurations 
		independently apply.
		
# Lets make one change
Change-1: Add second value to address space 
  address_space       = ["10.0.0.0/16", "10.1.0.0/16"] 

Change-2: Add new Virtual Network Resource
# Another VNET - New Resource - Enable the below at step-08
resource "azurerm_virtual_network" "myvent9" {
  name = "myvnet9"
  address_space = [ "10.2.0.0/16" ]
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name  
}


# List Resources from state
terraform state list

# Terraform plan
terraform plan
Observation:
1. Message: Plan: 1 to add, 1 to change, 0 to destroy.
2. 1 new VNET will be created
3. 1 change to existing VNET

# Terraform Plan with -target
terraform plan -target=azurerm_virtual_network.myvnet-new
Observation:
1) Message: "Plan: 0 to add, 1 to change, 0 to destroy"
2) It is updating Change-1 because we are targeting that resource "aws_instance.my-ec2-vm-new"
3) It is not touching the new resource which we are creating now "azurerm_virtual_network.myvent9". It will be in terraform configuration but not getting provisioned when we are using -target

# Terraform Apply
terraform apply -target=azurerm_virtual_network.myvnet-new
	
	
	
	
	
	------------------------------------------------------------------------------------------------------	
	Step-01: Introduction to "terraform apply -refresh-only" command
	------------------------------------------------------------------------------------------------------

terraform refresh in detail
---------------------------
	A "Terraform Inspecting State"
	
	
	terraform apply -refresh-only 
		reconcile state 
			Terraform knows 
				(via its state file) 
			with the real-world infrastructure.
		detect drift 
			from last-known state
			update the state file.
		does not modify cloud infrastructure
		modify the state file. 
		If the state is changed
			reflect in next plan or apply.
	Desired State: 
		Local Terraform Manifest 
			(All *.tf files)
	Current State: 
		Real Resources present in your cloud

lab/39
	terraform init
	terraform plan
	terraform apply
	
	Add the tag directly on the portal
	
	"tag3" = "my-tag-3"
	

plan compares in memory
	doens't apply 
	
Verify terraform.tfstate file 
	no changes
But it shows the differences of tags.

# Execute Terraform plan
terraform plan 

# Verify Terraform State File (recent timestamp)
ls -lrta 

# Review Terraform State file using terraform show command
terraform show 

# Execute terraform plan -refresh-only
terraform plan -refresh-only
	open state file and check
	#similar to plan will not update
terraform plan

# Execute terraform apply -refresh-only
terraform apply -refresh-only#state file is modified
	open state file and check
terraform plan
	configurations are still not updated
	
# Review terraform state file
1) terraform show
2) A new tag will be added to Azure Resource Group 
"tag3" = "my-tag-3"	


Update Configuration
-----------------
manual changes on 
	Azure Portal 
	in your state file 
		can track that change via Terraform.

update your TF Configs 
	(desired state) 
	
	
Add Tag3 referencing the state file.
uncomment tag3

# Run Terraform Plan
terraform plan
# Resource-1: Azure Resource Group
resource "azurerm_resource_group" "myrg" {
  name = "myrg1"
  location = "eastus"
  tags = {
    "tag1" = "my-tag-1"
    "tag2" = "my-tag-2"
    "tag3" = "my-tag-3"
  }
}

# Run Terraform Plan
terraform plan
Observation:
1. No changes to infrastructure
TF Configs (Desired State) - Good
TF State File - Good
Azure Portal (Current State) - Good


------------------------------------------------------------------------------------------------------	
	Step-02: Execute TF Commands with "terraform apply -refresh-only" and Clean-Up
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	

------------------------------------------------------------------------------------------------------
Terraform CLi with Workspace
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/cli/workspaces
	
	Terraform
		always works in a workspace
		starts with a single workspace 
			called "default"
				cannot be deleted
		can create named workspace
			conveniently switch between different workspace
				switch between multiple configuration with in 
					single backend
		convenient to do some testing etc.
			but comes with problems
			
					
	
	
	In Terraform CLI, 
		workspaces 
			separate instances of state data 
			can be used from the same working directory. 
		use workspaces to manage 
			multiple non-overlapping groups of resources 
				with the same configuration.

Every initialized working directory 
	has at least one workspace. 
		workspace called default
	(If you haven't created other workspaces, .)
For a working directory, 
	only one workspace can be selected at a time.
Most Terraform commands 
	(including provisioning and state manipulation commands) 
	only interact with the currently selected workspace.

terraform workspace select 
	select a new workspace.
terraform workspace list
terraform workspace new
terraform workspace delete 



Note: 
	Terraform Cloud and Terraform CLI 
		both have features called "workspaces," 
		slightly different. 
		Terraform Cloud's workspaces behave more like completely separate working directories.

Why Workspaces?
-------------------------
most of the resources 
	don't include a unique name 
		in configuration, 
	can use same Terraform configuration 
		to provision multiple groups of similar resources.
		e.g. staging and production
		
Problem: 
	Terraform uses state 
		to associate resources 
		with real-world objects, 
	if you run the same configuration 
		multiple times with 
		completely separate state data
		e.g. resouce group: (1) rg1 (2) rg2 (3) rg3
		Terraform is in trouble
		
	Terraform can manage many non-overlapping groups of resources.
	simple ways
		use variables 
			environment = stage, production
		use pattern like count 
	
	simplest solution 
		maintain separate directory 
			different 
				backend configurations 
				state configurations
	not convenient 
	
	Terraform installs separate 
		cache of plugins and 
		modules for each working directory, 
	so maintaining multiple directories 
		waste bandwidth and 
		disk space. 
		maintaince overhead
			update configuration code from version control separately 
		reinitialize each directory separately 
			when changing the 
			configuration, etc.

	Workspaces 
		use the same 
			working directory 
			plugin and 
			module caches, 
		keep separate states 
			for each collection of resources you manage.

N.B.:
	Terraform workspace 
		terraform cli 
	completely different from 
		terraform cloud

Interactions with Terraform Cloud Workspaces (can skip)
-------------------------------------------------------
Terraform Cloud organizes infrastructure using workspaces, but its workspaces act more like completely separate working directories; each Terraform Cloud workspace has its own Terraform configuration, set of variable values, state data, run history, and settings.

These two kinds of workspaces are different, but related. When using Terraform CLI as a frontend for Terraform Cloud, you can associate the current working directory with one or more remote workspaces. If you associate the directory with multiple workspaces (using workspace tags), you can use the terraform workspace commands to select which remote workspace to use.


Refer to CLI-driven Runs in the Terraform Cloud documentation for more details about using Terraform CLI with Terraform Cloud.




	Step-02: Review TF Configs and understand terraform.workspace variable
	------------------------------------------------------------------------------------------------------
	
	We will 
		use Terraform Local Backend
		create 2 workspaces 
			(default, dev) 
			in addition to default workspace
	Update our terraform manifests/configuration to support terraform workspace


	
	------------------------------------------------------------------------------------------------------	
	Step-03: Create Resources in default workspace and learn commands workspace list
	------------------------------------------------------------------------------------------------------
	
lab/40	
${terraform.workspace} - default workspace
	available by default 
	modified local for this.
	

# Terraform Init
terraform init 

# List Workspaces
terraform workspace list

# Output Current Workspace using show
terraform workspace show

# Terraform Plan
terraform plan
Observation: 
1. The names of Resources should have "default" in them in place of environment
2. Resource Group Name: it-default-rg
3. Virtual Network: it-default-vnet
4. Subnet Name: it-default-subnet
5. Public IP Name: it-default-publicip
6. Network Interface Name: it-default-nic
7. Virtual Machine Name: it-default-vm

# Terraform Apply
terraform apply -auto-approve

# Verify
Verify the same in Azure Management console
Observation: 
1. The names of Resources should have "default" in them in place of environment
2. Resource Group Name: it-default-rg
3. Virtual Network: it-default-vnet
4. Subnet Name: it-default-subnet
5. Public IP Name: it-default-publicip
6. Network Interface Name: it-default-nic
7. Virtual Machine Name: it-default-vm

# Access Application
http://<public-ip-dns-name>
	------------------------------------------------------------------------------------------------------	
	Step-04: Create new workspace, create resources and understand state files
	------------------------------------------------------------------------------------------------------

lab/40-1	
	
	
# Create New Workspace
terraform workspace new dev

# Verify the folder
cd terraform.tfstate.d 
cd dev
ls
cd ../../

# Terraform Plan
terraform plan
Observation:  
1. The names of Resources should have "dev" in them in place of environment
2. Resource Group Name: it-dev-rg
3. Virtual Network: it-dev-vnet
4. Subnet Name: it-dev-subnet
5. Public IP Name: it-dev-publicip
6. Network Interface Name: it-dev-nic
7. Virtual Machine Name: it-dev-vm


# Terraform Apply
terraform apply -auto-approve

# Verify Dev Workspace statefile
cd terraform.tfstate.d/dev
ls
cd ../../
Observation: You should fine "terraform.tfstate" in "current-working-directory/terraform.tfstate.d/dev" folder

# Verify Resources in Azure mgmt console
Observation:
1. The names of Resources should have "dev" in them in place of environment
2. Resource Group Name: it-dev-rg
3. Virtual Network: it-dev-vnet
4. Subnet Name: it-dev-subnet
5. Public IP Name: it-dev-publicip
6. Network Interface Name: it-dev-nic
7. Virtual Machine Name: it-dev-vm

# Access Application
http://<public-ip-dns-name>	


# Show current workspace
terraform workspace show

# List Worksapces
terraform workspace list

# Workspace select
terraform workspace select default

# Delete Resources from default workspace
#don't do - terraform destroy -auto-approve

# Verify
1) Verify in Azure Mgmt Console (all the resources should be deleted)

	------------------------------------------------------------------------------------------------------	
	Step-05: Learn to delete resources in workspaces and deleting workspaces
	------------------------------------------------------------------------------------------------------

lab/40-2
We cannot delete "default" workspace
We can delete workspaces which we created (dev, qa etc)

# Delete Dev Workspace
terraform workspace delete dev
Observation: Workspace "dev" is not empty.
Deleting "dev" 
	can result in dangling resources: 
		resources exist 
		but are no longer manageable by Terraform. 
		Please destroy these resources first.  
		If you want to delete this workspace anyway and risk dangling resources, 
		use the '-force' flag.

# Switch to Dev Workspace
terraform workspace select dev

# Destroy Resources
terraform destroy -auto-approve

# Delete Dev Workspace
terraform workspace delete dev
Observation:
Workspace "dev" is your active workspace.
You cannot delete the currently active workspace. Please switch
to another workspace and try again.

# Switch Workspace to default
terraform workspace select default

# Delete Dev Workspace
terraform workspace delete dev
Observation: Successfully delete workspace dev

	------------------------------------------------------------------------------------------------------	
	Step-06: Implement CLI Workspaces with Remote State Storage Backend
	------------------------------------------------------------------------------------------------------
Start from here
lab/40-3

Add Backend block in Terraform Settings block
# Terraform State Storage to Azure Storage Container
  backend "azurerm" {
    resource_group_name   = "terraform-storage-rg"
    storage_account_name  = "terraformstate201"
    container_name        = "tfstatefiles"
    key                   = "cliworkspaces-terraform.tfstate"
  }   

# Terraform Init
terraform init 
Observation:
1. Go to Azure Management Console -> terraform-storage-tg -> terraformstate201 -> tfstatefiles
2. Verify file with name "cliworkspaces-terraform.tfstate"
3. Verify file size (Approx 155B)

# List Workspaces
terraform workspace list

# Output Current Workspace using show
terraform workspace show

# Create Workspaces
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

# Verify the workspace file names in Storage Account
cliworkspaces-terraform.tfstate:dev
cliworkspaces-terraform.tfstate:staging
cliworkspaces-terraform.tfstate:prod

# Delete Workspaces
terraform workspace select default
terraform workspace delete dev
terraform workspace delete staging
terraform workspace delete prod


terraform destroy

	------------------------------------------------------------------------------------------------------	

------------------------------------------------------------------------------------------------------
Terraform Provisioner
------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/resources/provisioners/syntax
	Provisioners
You can use provisioners to model specific actions on the local machine or on a remote machine in order to prepare servers or other infrastructure objects for service.

Note: We removed the Chef, Habitat, Puppet, and Salt Masterless provisioners in Terraform v0.15.0. Information about these legacy provisioners is still available in the documentation for Terraform v1.1 (and earlier).

»Provisioners are a Last Resort
Hands-on: 
	Try the Provision Infrastructure Deployed with Terraform tutorials to learn about more declarative ways to handle provisioning actions.

Terraform includes the concept of provisioners as a measure of pragmatism, knowing that there are always certain behaviors that cannot be directly represented in Terraform's declarative model.

However, they also add a considerable amount of complexity and uncertainty to Terraform usage. Firstly, Terraform cannot model the actions of provisioners as part of a plan because they can in principle take any action. Secondly, successful use of provisioners requires coordinating many more details than Terraform usage usually requires: direct network access to your servers, issuing Terraform credentials to log in, making sure that all of the necessary external software is installed, etc.

The following sections describe some situations which can be solved with provisioners 
in principle, but where better solutions are also available. 
We do not recommend using provisioners for any of the use-cases 
described in the following sections.

Even if your specific use-case is not described in the following sections, we still recommend attempting to solve it using other techniques first, and use provisioners only if there is no other option.

»Passing data into virtual machines and other compute resources
When deploying virtual machines or other similar compute resources, we often need to pass in data about other related infrastructure that the software on that server will need to do its job.

The various provisioners that interact with remote servers over SSH or WinRM can potentially be used to pass such data by logging in to the server and providing it directly, but most cloud computing platforms provide mechanisms to pass data to instances at the time of their creation such that the data is immediately available on system boot. For example:

Alibaba Cloud: user_data on alicloud_instance or alicloud_launch_template.
Amazon EC2: user_data or user_data_base64 on aws_instance, aws_launch_template, and aws_launch_configuration.
Amazon Lightsail: user_data on aws_lightsail_instance.
Microsoft Azure: custom_data on azurerm_virtual_machine or azurerm_virtual_machine_scale_set.
Google Cloud Platform: metadata on google_compute_instance or google_compute_instance_group.
Oracle Cloud Infrastructure: metadata or extended_metadata on oci_core_instance or oci_core_instance_configuration.
VMware vSphere: Attach a virtual CDROM to vsphere_virtual_machine using the cdrom block, containing a file called user-data.txt.
Many official Linux distribution disk images include software called cloud-init that can automatically process in various ways data passed via the means described above, allowing you to run arbitrary scripts and do basic system configuration immediately during the boot process and without the need to access the machine over SSH.

Hands-on: Try the Provision Infrastructure with Cloud-Init tutorial.

If you are building custom machine images, you can make use of the "user data" or "metadata" passed by the above means in whatever way makes sense to your application, by referring to your vendor's documentation on how to access the data at runtime.

This approach is required if you intend to use any mechanism in your cloud provider for automatically launching and destroying servers in a group, because in that case individual servers will launch unattended while Terraform is not around to provision them.

Even if you're deploying individual servers directly with Terraform, passing data this way will allow faster boot times and simplify deployment by avoiding the need for direct network access from Terraform to the new server and for remote access credentials to be provided.

»Running configuration management software
As a convenience to users who are forced to use generic operating system distribution images, Terraform includes a number of specialized provisioners for launching specific configuration management products.

We strongly recommend not using these, and instead running system configuration steps during a custom image build process. For example, HashiCorp Packer offers a similar complement of configuration management provisioners and can run their installation steps during a separate build process, before creating a system disk image that you can deploy many times.

Hands-on: Try the Provision Infrastructure with Packer tutorial.

If you are using configuration management software that has a centralized server component, you will need to delay the registration step until the final system is booted from your custom image. To achieve that, use one of the mechanisms described above to pass the necessary information into each instance so that it can register itself with the configuration management server immediately on boot, without the need to accept commands from Terraform over SSH or WinRM.

»First-class Terraform provider functionality may be available
It is technically possible to use the local-exec provisioner to run the CLI for your target system in order to create, update, or otherwise interact with remote objects in that system.

If you are trying to use a new feature of the remote system that isn't yet supported in its Terraform provider, that might be the only option. However, if there is provider support for the feature you intend to use, prefer to use that provider functionality rather than a provisioner so that Terraform can be fully aware of the object and properly manage ongoing changes to it.

Even if the functionality you need is not available in a provider today, we suggest to consider local-exec usage a temporary workaround and to also open an issue in the relevant provider's repository to discuss adding first-class provider support. Provider development teams often prioritize features based on interest, so opening an issue is a way to record your interest in the feature.

Provisioners are used to execute scripts on a local or remote machine as part of resource creation or destruction. Provisioners can be used to bootstrap a resource, cleanup before destroy, run configuration management, etc.

»How to use Provisioners
Note: Provisioners should only be used as a last resort. For most common situations there are better alternatives. For more information, see the sections above.

If you are certain that provisioners are the best way to solve your problem after considering the advice in the sections above, you can add a provisioner block inside the resource block of a compute instance.

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo The server's IP address is ${self.private_ip}"
  }
}

The local-exec provisioner requires no other configuration, but most other provisioners must connect to the remote system using SSH or WinRM. You must include a connection block so that Terraform knows how to communicate with the server.

Terraform includes several built-in provisioners. You can also use third-party provisioners as plugins, by placing them in %APPDATA%\terraform.d\plugins, ~/.terraform.d/plugins, or the same directory where the Terraform binary is installed. However, we do not recommend using any provisioners except the built-in file, local-exec, and remote-exec provisioners.

All provisioners support the when and on_failure meta-arguments, which are described below (see Destroy-Time Provisioners and Failure Behavior).

»The self Object
Expressions in provisioner blocks cannot refer to their parent resource by name. Instead, they can use the special self object.

The self object represents the provisioner's parent resource, and has all of that resource's attributes. For example, use self.public_ip to reference an aws_instance's public_ip attribute.

Technical note: Resource references are restricted here because references create dependencies. Referring to a resource by name within its own block would create a dependency cycle.

»Suppressing Provisioner Logs in CLI Output
The configuration for a provisioner block may use sensitive values, such as sensitive variables or sensitive output values. In this case, all log output from the provisioner is automatically suppressed to prevent the sensitive values from being displayed.

»Creation-Time Provisioners
By default, provisioners run when the resource they are defined within is created. Creation-time provisioners are only run during creation, not during updating or any other lifecycle. They are meant as a means to perform bootstrapping of a system.

If a creation-time provisioner fails, the resource is marked as tainted. A tainted resource will be planned for destruction and recreation upon the next terraform apply. Terraform does this because a failed provisioner can leave a resource in a semi-configured state. Because Terraform cannot reason about what the provisioner does, the only way to ensure proper creation of a resource is to recreate it. This is tainting.

You can change this behavior by setting the on_failure attribute, which is covered in detail below.

»Destroy-Time Provisioners
If when = destroy is specified, the provisioner will run when the resource it is defined within is destroyed.

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    when    = destroy
    command = "echo 'Destroy-time provisioner'"
  }
}

Destroy provisioners are run before the resource is destroyed. If they fail, Terraform will error and rerun the provisioners again on the next terraform apply. Due to this behavior, care should be taken for destroy provisioners to be safe to run multiple times.

Destroy provisioners of this resource will not run if `create_before_destroy`
is set to `true`. We may address this in the future, and this [GitHub issue](https://github.com/hashicorp/terraform/issues/13549) contains more details.

Destroy-time provisioners can only run if they remain in the configuration at the time a resource is destroyed. If a resource block with a destroy-time provisioner is removed entirely from the configuration, its provisioner configurations are removed along with it and thus the destroy provisioner won't run. To work around this, a multi-step process can be used to safely remove a resource with a destroy-time provisioner:

Update the resource configuration to include count = 0.
Apply the configuration to destroy any existing instances of the resource, including running the destroy provisioner.
Remove the resource block entirely from configuration, along with its provisioner blocks.
Apply again, at which point no further action should be taken since the resources were already destroyed.
This limitation may be addressed in future versions of Terraform. For now, destroy-time provisioners must be used sparingly and with care.

NOTE: A destroy-time provisioner within a resource that is tainted will not run. This includes resources that are marked tainted from a failed creation-time provisioner or tainted manually using terraform taint.

»Multiple Provisioners
Multiple provisioners can be specified within a resource. Multiple provisioners are executed in the order they're defined in the configuration file.

You may also mix and match creation and destruction provisioners. Only the provisioners that are valid for a given operation will be run. Those valid provisioners will be run in the order they're defined in the configuration file.

Example of multiple provisioners:

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo first"
  }

  provisioner "local-exec" {
    command = "echo second"
  }
}

»Failure Behavior
By default, provisioners that fail will also cause the Terraform apply itself to fail. The on_failure setting can be used to change this. The allowed values are:

continue - Ignore the error and continue with creation or destruction.

fail - Raise an error and stop applying (the default behavior). If this is a creation provisioner, taint the resource.

Example:

resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command    = "echo The server's IP address is ${self.private_ip}"
    on_failure = continue
  }
}





Reference: 
https://www.terraform.io/docs/language/resources/provisioners/file.html

Provisioner
	used to model actions on 
		local machine
	or 
		remote machine
			to prepare servers
			
	e.g. used to Pass data into vm's
	run configuration management 
		e.g. packer, chef, ansible
	Recommendation: use it as the last resort
		there can be other ways in Terraform
	can run at 2 times 
		creation-time
		destroy-time
	2 failure behaviour
		Failure behaviour:Continue
			Ignore Error and continue
		Failure behaviour:Fail
			Raise and error and stop
			Default
			taint resource
			apply and destroy fails
	
	3 types
		File provisioners
		Remote provisioners
		local-exec provisioners
		
	Most provisioners
		require access to remote resources
			via
				SSH
				WinRM
			expect 
				nested connection block
connection {
	type = "ssh"
	host = self.public_ip_address
	user = self.admin_username
	private_key = file ("${path.module}/ssh-keys/terraform-azure.pem")
}					
		
	File Provisioners
		copy files or directories 
			from the machine executing Terraform 
				to a newly created resource
		support both 
			ssh and winrm
		e.g. copy a file
	Local exec provisioners
		invokes a local executable
			after a resource is created
		invokes a process on the machine running Terraform
			not on the resource
		can run in 2 diff. times
			creation time provisioners
			destroy time provisioners
				when = destroy
		e.g. log creation and destroy time.		
	Remote exec provisioners
		invokes a script on a remote resource
			after it is created
		e.g. run a configuration management tool 
			bootstrap into a cluster
				etc.
				
	Null-Resources & Provisioners
		Run provisioners not associated with a specific resource
		treated like normal resources
			don't do anything
		Can configure provisioners and connectino details.
		e.g. sleep for 10 sec.	
				




	Step-01: Understand File Provisioner, Self Object and Create Connection Block
	------------------------------------------------------------------------------------------------------

Create SSH Keys for Azure VM Instance if not created
# Create Folder
cd terraform-manifests/
mkdir ssh-keys

# Create SSH Key
cd ssh-ekys
ssh-keygen \
    -m PEM \
    -t rsa \
    -b 4096 \
    -C "azureuser@myserver" \
    -f terraform-azure.pem 
Important Note: If you give passphrase during generation, during everytime you login to VM, you also need to provide passphrase.

# List Files
ls -lrt ssh-keys/

# Files Generated after above command 
Public Key: terraform-azure.pem.pub -> Rename as terraform-azure.pub
Private Key: terraform-azure.pem

# Permissions for Pem file
chmod 400 terraform-azure.pem


Connection Block 
	for provisioners 
		connect to newly created Azure VM instance 
			copy files using file provisioner
				execute scripts using remote-exec provisioner


Connection Block
----------------
connection block 
	inside resource block 
		for all provisioners
[or]
	inside a provisioner block 
		for that respective provisioner

Self Object
-----------
N.B: 
	Resource references are restricted here 
		references create dependencies.
		Referring to a resource by name 
			its own block 
				would create a dependency cycle.
Expressions in provisioner blocks 
	cannot refer to their parent resource 
		by name. 
	Instead
		use special self object.
self object 
	represents the provisioner's parent resource, 
	has all of that resource's attributes.
  # Connection Block for Provisioners to connect to Azure Virtual Machine
  connection {
    type = "ssh"
    host = self.public_ip_address # Understand what is "self"
    user = self.admin_username
    password = ""
    private_key = file("${path.module}/ssh-keys/terraform-azure.pem")
  }  



			
			

	------------------------------------------------------------------------------------------------------	
	Step-02: Understand Creation-Time Provisioner and Create File Provisioners
	------------------------------------------------------------------------------------------------------

Creation-Time Provisioners:
--------------------------
By default
	provisioners run 
		when resource they are defined within is created.
Creation-time provisioners 
	run only during creation
	not during update or 
		any other lifecycle.
	bootstrap a system.
	creation-time provisioner fails
		resource is marked as tainted.
			failed provisioner 
				can leave a resource 
					in a semi-configured state.
	Terraform cannot understand/control 
		provisioner does
			so recreate it. 
		This is tainting.
		on_failure attribute modifies this (to follow).
 # File Provisioner-1: Copies the file-copy.html file to /tmp/file-copy.html
  provisioner "file" {
    source      = "apps/file-copy.html"
    destination = "/tmp/file-copy.html"
  }

  # File Provisioner-2: Copies the string in content into /tmp/file.log
  provisioner "file" {
    content     = "VM Host Name: ${self.computer_name}" # Understand what is "self"
    destination = "/tmp/file.log"
  }

  # File Provisioner-3: Copies the app1 folder to /tmp - FOLDER COPY
  provisioner "file" {
    source      = "apps/app1"
    destination = "/tmp"
  }

  # File Provisioner-4: Copies all files and folders in apps/app2 to /tmp - CONTENTS of FOLDER WILL BE COPIED
  provisioner "file" {
    source      = "apps/app2/" # when "/" at the end is added - CONTENTS of FOLDER WILL BE COPIED
    destination = "/tmp"
  }

	------------------------------------------------------------------------------------------------------	
	Step-03: Execute TF Commands and Verify Files provisioned to Linux VM
	------------------------------------------------------------------------------------------------------
	
	

lab/41
	44

Add ssh keys



# Terraform Initialize
terraform init

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve

# Verify - Login to Azure Virtual Machine Instance
ssh -i ssh-keys/terraform-azure.pem azureuser@IP_ADDRESSS_OF_YOUR_VM
ssh -i ssh-keys/terraform-azure.pem azureuser@20.185.30.127
Verify /tmp for all files copied
cd /tmp
ls -lrta /tmp

# Clean-up
terraform destroy -auto-approve
rm -rf terraform.tfsate*
Observation: 
Q1: Why do we need to destroy and move with next steps?
A1: 
1. Provisioners can be created during resource creation-time or destroy-time. 
2. With that said, we need to test failure case of a provisioner which will faill "terraform apply". 
3. We will understand that in next few steps. 
	
	------------------------------------------------------------------------------------------------------	
	Step-04: Provisioners on_failure = continue or fail verify and cleanup
	------------------------------------------------------------------------------------------------------

Decision making when provisioner fails (continue / fail)
----------------------------------------------------
default, 
	provisioners failure
	Terraform apply fail. 
	use on_failure setting 
		change this. 
	allowed values are:
		continue: 
			Ignore the error 
			continue with creation or destruction.
		fail: (Default Behavior) 
			Raise an error 
			stop applying (the default behavior). 
			If this is a creation provisioner, 
				taint the resource.


Lab/41-2
	copying a file 
		to Apache static content folder 
		"/var/www/html" 
		using file-provisioner
This will fail because
	user is: "azureuser" 
	for Azure linux vm. 
		don't have access to "/var/www/html/" top copy files.
	
	use sudo to do that.

cannot copy it directly
	but 
		we have already copied 
		this file in "/tmp" 
		using file provisioner

Try two scenarios
1. No on_failure attribute 
	(Same as on_failure = fail) - 
	default 
		Raise an error 
		stop applying. 
	If this is a creation provisioner
		taint the resource.
2. When on_failure = continue
	continue creating resources

Verify terraform.tfstate for "status": "tainted"


Reference
lab/41
lab/41-3

Modify provisioner in main.tf vm section
	Modify destination
	we don't have access to this folder

# Test-1: Without on_failure attribute which will fail terraform apply
 # Copies the file-copy.html file to /var/www/html/file-copy.html
  provisioner "file" {
    source      = "apps/file-copy.html"
    destination = "/var/www/html/file-copy.html"
   }


# Terraform Validate
terraform destroy # update may not succeed
terraform validate

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve   

# Verify:  
Verify terraform.tfstate for  "status": "tainted"

## Sample Failure Log
azurerm_linux_virtual_machine.mylinuxvm: Provisioning with 'file'...
azurerm_linux_virtual_machine.mylinuxvm: Still creating... [3m0s elapsed]
╷
│ Error: file provisioner error
│ 
│   with azurerm_linux_virtual_machine.mylinuxvm,
│   on c6-linux-virtual-machine.tf line 71, in resource "azurerm_linux_virtual_machine" "mylinuxvm":
│   71:   provisioner "file" {
│ 
│ Upload failed: scp: /var/www/html/file-copy.html: Permission denied
╵



Continue Case
-------------
lab/41-4
Uncomment on_failure = continue
# Test-2: With on_failure = continue
 # Copies the file-copy.html file to /var/www/html/file-copy.html
  provisioner "file" {
    source      = "apps/file-copy.html"
    destination = "/var/www/html/file-copy.html"
    on_failure  = continue 
   }
# Terraform Validate
terraform validate

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve

# Verify
1. Login to Azure VM Instance
ssh -i ssh-keys/terraform-azure.pem azureuser@<VM-PUBLIC-IP>
ssh -i ssh-keys/terraform-azure.pem azureuser@20.102.55.82


2. Verify /tmp - for all files copied
3. Verify /var/www/html - file-copy.html should not be copied
4. File Provisioner didn't do job of file copy but still it didn't get fail due to the fact that we used "on_failure  = continue"



Theory 
------
	when    = destroy 
	will get executed during desroy
Inside a provisioner when you add this statement when = destroy it will provision this during the resource destroy time
resource "azurerm_linux_virtual_machine" "mylinuxvm" {
  # ...

  provisioner "local-exec" {
    when    = destroy 
    command = "echo 'Destroy-time provisioner'"
  }
}

	------------------------------------------------------------------------------------------------------	
	Step-05: Remote-exec Provisioner Demo
	------------------------------------------------------------------------------------------------------

We will copy a file 
	named file-copy.html 
	using File Provisioner to "/tmp" directory
Using remote-exec provisioner
	and linux commands 
	copy the file to Apache Webserver static content directory 
		/var/www/html 
		

lab/42

#set up ssh-keys before using it.
		
Add
 # Copies the file-copy.html file to /tmp/file-copy.html
  provisioner "file" {
    source      = "apps/file-copy.html"
    destination = "/tmp/file-copy.html"
  }

# Copies the file to Apache Webserver /var/www/html directory
  provisioner "remote-exec" {
    inline = [
      "sleep 120",  # Will sleep for 120 seconds to ensure Apache webserver is provisioned using custom_data
      "sudo cp /tmp/file-copy.html /var/www/html"
    ]
  }
  
  
  
	------------------------------------------------------------------------------------------------------	
	Step-06: Local-exec Provisioner Demo
	------------------------------------------------------------------------------------------------------

	The local-exec provisioner 
		invokes a local executable 
		after a resource is created.
	This invokes a process 
		on the machine running Terraform, 
		not on the resource.

	Let's create 
		one provisioner 
			during creation-time. 
				output private ip of the instance 
				in to a file named creation-time.txt
		another provisioner 
			during destroy time. 
				output destroy time 
					with date in to a file 
					named destroy-time.txt

lab/43
46



add in main.tf
  # local-exec provisioner (Creation-Time Provisioner - Triggered during Create Resource)
  provisioner "local-exec" {
    command = "echo ${azurerm_linux_virtual_machine.mylinuxvm.public_ip_address} >> creation-time.txt"
    working_dir = "local-exec-output-files/"
    #on_failure = continue
  }

  # local-exec provisioner - (Destroy-Time Provisioner - Triggered during Destroy Resource)
  provisioner "local-exec" {
    when    = destroy
    command = "echo Destroy-time provisioner Instanace Destroyed at `date` >> destroy-time.txt"
    working_dir = "local-exec-output-files/"
  }
	
	
# Terraform Initialize
terraform init

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve	
	------------------------------------------------------------------------------------------------------	

	Step-01: Understand Null and Time Resources and Create Time Resource
	------------------------------------------------------------------------------------------------------

Null provider
	Unusual provider
	like random
	need to add into terraform block.
	https://registry.terraform.io/providers/hashicorp/null/latest/docs
	
Time Provider
	used to interact with time-based resources
	Provier has no configuration options
	need to add into terraform block.
	https://registry.terraform.io/providers/hashicorp/time/latest/docs
	
	
Null Resource
	https://www.terraform.io/docs/language/resources/provisioners/null_resource.html
	
Usecase: 
	Force a resource to 
		update based on a changed null_resource

Create time_sleep resource 
	wait for 90 seconds 
	after Azure Linux VM Instance creation
Create Null resource with required provisioners

File Provisioner: 
	Copy apps/app1 folder to /tmp
Remote Exec Provisioner: 
	Copy app1 folder from /tmp to /var/www/html
	
To learn 
	null_resource
	time_sleep resource
	how to Force a resource 
		to update 
		based on a changed null_resource 
		using timestamp function and 
		triggers in null_resource	
 



Create Time Sleep Resource
----------------------------------
resource will wait for 90 seconds 
	after VM Instance creation.
This wait time will give VM Instance to provision 
	the Apache Webserver and 
	create all its relevant folders
Primarily if we want to copy static content 
	we need Apache webserver static folder /var/www/html

# Wait for 90 seconds after creating the above Azure Virtual Machine Instance 
resource "time_sleep" "wait_90_seconds" {
  depends_on = [azurerm_linux_virtual_machine.mylinuxvm]
  create_duration = "90s"
}



Create Null Resource
-----------------
	triggers with timestamp() function 
		trigger for every terraform apply
	help us to sync 
		the static content 
		from our local folder to 
		VM Instnace 
			as and when required.
	Changes will be applied 
		using only null_resource 
		when terraform apply is run. 
	when static content changes
		how to sync those changes to VM Instance using terraform - 
			A simple solution.
	
lab/44
Added the below


Following providers are updated in provider.tf
    null = {
      source = "hashicorp/null"
      version = ">= 3.0.0"
    }
	
    time = {
      source = "hashicorp/time"
      version = ">= 0.6.0"
    } 
	
# Terraform NULL RESOURCE
# Sync App1 Static Content to Webserver using Provisioners
resource "null_resource" "sync_app1_static" {
  depends_on = [ time_sleep.wait_90_seconds ]
#id will be associated with timestamp. Any change. Null resource will be recreated.
  triggers = {
    always-update =  timestamp()
  }
}
  # Connection Block for Provisioners to connect to Azure VM Instance
  connection {
    type = "ssh"
    host = azurerm_linux_virtual_machine.mylinuxvm.public_ip_address 
    user = azurerm_linux_virtual_machine.mylinuxvm.admin_username
    private_key = file("${path.module}/ssh-keys/terraform-azure.pem")
  }  

 # Copies the app1 folder to /tmp
  provisioner "file" {
    source      = "apps/app1"
    destination = "/tmp"
  }

# Copies the /tmp/app1 folder to Apache Webserver /var/www/html directory
  provisioner "remote-exec" {
    inline = [
      "sudo cp -r /tmp/app1 /var/www/html"
    ]
  }
}



Add ssh-keys

# Terraform Initialize
terraform init

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve

# Verify
ssh -i ssh-keys/terraform-azure.pem azureuser@<PUBLIC-IP>
ls -lrt /tmp
ls -lrt /tmp/app1
ls -lrt /var/www/html
ls -lrt /var/www/html/app1
http://<public-ip>/app1/app1-file1.html
http://<public-ip>/app1/app1-file2.html


Modify app1
add a file and modify a file
re-run 
	terraform plan 
	terraform apply
	
------------------------------------------------------------------------------------------------------	
	Step-02: Create Null Resource, File and remote-exec Provisioners and Triggers
	------------------------------------------------------------------------------------------------------

	Create a new file named app1-file3.html
	Also updated app1-file1.html with some additional info
	file3.html, file1.html
	
	
terraform plan
Observation: You should see changes for "null_resource.sync_app1_static" because trigger will have new timestamp when you fired the terraform plan command

# Terraform Apply
terraform apply -auto-approve

# Verify
ssh -i ssh-keys/terraform-azure.pem azureuser@<PUBLIC-IP>
ls -lrt /tmp
ls -lrt /tmp/app1
ls -lrt /var/www/html
ls -lrt /var/www/html/app1
http://<public-ip>/app1/app1-file1.html
http://<public-ip>/app1/app1-file3.html


terraform destroy
	------------------------------------------------------------------------------------------------------	
	Step-03: Execute TF Commands, Verify Static Content and Understand more about null
	------------------------------------------------------------------------------------------------------

	already covered
	------------------------------------------------------------------------------------------------------	
	Step-01: Understand Terraform Import and Import Resource Group
	------------------------------------------------------------------------------------------------------

Terraform can import existing infrastructure.
Bring directly provisioned resources 
	under Terraform management.
	Great way to 
		slowly transition infrastructure to Terraform
	or 
		confident that Terraform can manage resources tomorrow 
			for features which are not supported today.
	
N.B:
	import to state file only 
	configurations are not updated.
	
	


continue from here

lab/47
Step 1
Create Azure Resource Group using Azure Mgmt Console
Login to Azure Portal Management Console
Go to -> Resource Groups -> Create
Resource Group: myrg1
Region: East US
Click on Review + create
Click on Create

Step 2: Create Basic Terraform Configuration
provider.tf
main.tf
Create a base Azure Resource Group resource
# Create Azure Resource Group Resource - Basic Version to get Terraform Resource Type and Resource Local Name we are going to use in Terraform
# Resource Group
resource "azurerm_resource_group" "myrg" {


# Terraform Initialize
terraform init

# Terraform Import Command for Azure Resource Group

To get the below string for any object.
Go to the resource
	top right there is a json view link.
	Click on the same and we would get the below string 

terraform import azurerm_resource_group.example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/example
terraform import azurerm_resource_group.example /subscriptions/<SUBSCRIPTION_ID>/resourceGroups/<RESOURCE_GROUP_NAME>
terraform import azurerm_resource_group.myrg /subscriptions/82808767-144c-4c66-a320-b30791668b0a/resourceGroups/myrg1

Observation:
1) terraform.tfstate file will be created locally in Terraform working directory
2) Review information about imported instance configuration in terraform.tfstate

# List Resources from Terraform State
terraform state list

terraform plan

Building local c2-resource-group.tf
By referring terraform.tfstate file and parallely running terraform plan command make changes to your terraform configuration c2-resource-group.tf till you get the message No changes. Infrastructure is up-to-date for terraform plan output
# Resource Group
resource "azurerm_resource_group" "myrg" {
  name = "myrg1"
  location = "eastus"
}



 Modify Resource Group from Terraform
You have created this Azure Resource Group manually and now you made it as terraform managed
Modify this resource group by adding new tags
# Resource Group
resource "azurerm_resource_group" "myrg" {
  name = "myrg1"
  location = "eastus"
  tags = {
    "Tag1" = "My-tag-1"
  }
}


# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve
Observation:
1) Azure Resource Group on Azure Cloud should have the recently added tags. 



	------------------------------------------------------------------------------------------------------	
	Step-02: Create RG Resource by referring TFSTATE file, Verify and CleanUp
	------------------------------------------------------------------------------------------------------

	covered above
	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------
Terraform Module
------------------------------------------------------------------------------------------------------
	Step-01: Understand Terraform Modules and its features
	------------------------------------------------------------------------------------------------------
	https://www.terraform.io/language/modules/syntax
	
	A module is a container for multiple resources that are used together.

Every Terraform configuration has at least one module, known as its root module, which consists of the resources defined in the .tf files in the main working directory.

A module can call other modules, which lets you include the child module's resources into the configuration in a concise way. Modules can also be called multiple times, either within the same configuration or in separate configurations, allowing resource configurations to be packaged and re-used.

This page describes how to call one module from another. For more information about creating re-usable child modules, see Module Development.


Calling a Child Module
To call a module means to include the contents of that module into the configuration with specific values for its input variables. Modules are called from within other modules using module blocks:

module "servers" {
  source = "./app-cluster"

  servers = 5
}

A module that includes a module block like this is the calling module of the child module.

The label immediately after the module keyword is a local name, which the calling module can use to refer to this instance of the module.

Within the block body (between { and }) are the arguments for the module. Module calls use the following kinds of arguments:

The source argument is mandatory for all modules.

The version argument is recommended for modules from a registry.

Most other arguments correspond to input variables defined by the module. (The servers argument in the example above is one of these.)

Terraform defines a few other meta-arguments that can be used with all modules, including for_each and depends_on.

»Source
All modules require a source argument, which is a meta-argument defined by Terraform. Its value is either the path to a local directory containing the module's configuration files, or a remote module source that Terraform should download and use. This value must be a literal string with no template sequences; arbitrary expressions are not allowed. For more information on possible values for this argument, see Module Sources.

The same source address can be specified in multiple module blocks to create multiple copies of the resources defined within, possibly with different variable values.

After adding, removing, or modifying module blocks, you must re-run terraform init to allow Terraform the opportunity to adjust the installed modules. By default this command will not upgrade an already-installed module; use the -upgrade option to instead upgrade to the newest available version.

»Version
When using modules installed from a module registry, we recommend explicitly constraining the acceptable version numbers to avoid unexpected or unwanted changes.

Use the version argument in the module block to specify versions:

module "consul" {
  source  = "hashicorp/consul/aws"
  version = "0.0.5"

  servers = 3
}
The version argument accepts a version constraint string. Terraform will use the newest installed version of the module that meets the constraint; if no acceptable versions are installed, it will download the newest version that meets the constraint.

Version constraints are supported only for modules installed from a module registry, such as the public Terraform Registry or Terraform Cloud's private module registry. Other module sources can provide their own versioning mechanisms within the source string itself, or might not support versions at all. In particular, modules sourced from local file paths do not support version; since they're loaded from the same source repository, they always share the same version as their caller.

»Meta-arguments
Along with source and version, Terraform defines a few more optional meta-arguments that have special meaning across all modules, described in more detail in the following pages:

count - Creates multiple instances of a module from a single module block. See the count page for details.

for_each - Creates multiple instances of a module from a single module block. See the for_each page for details.

providers - Passes provider configurations to a child module. See the providers page for details. If not specified, the child module inherits all of the default (un-aliased) provider configurations from the calling module.

depends_on - Creates explicit dependencies between the entire module and the listed targets. See the depends_on page for details.

In addition to the above, the lifecycle argument is not currently used by Terraform but is reserved for planned future features.

»Accessing Module Output Values
The resources defined in a module are encapsulated, so the calling module cannot access their attributes directly. However, the child module can declare output values to selectively export certain values to be accessed by the calling module.

For example, if the ./app-cluster module referenced in the example above exported an output value named instance_ids then the calling module can reference that result using the expression module.servers.instance_ids:

resource "aws_elb" "example" {
  # ...

  instances = module.servers.instance_ids
}

For more information about referring to named values, see Expressions.

»Transferring Resource State Into Modules
Moving resource blocks from one module into several child modules causes Terraform to see the new location as an entirely different resource. As a result, Terraform plans to destroy all resource instances at the old address and create new instances at the new address.

To preserve existing objects, you can use refactoring blocks to record the old and new addresses for each resource instance. This directs Terraform to treat existing objects at the old addresses as if they had originally been created at the corresponding new addresses.

»Replacing resources within a module
You may have an object that needs to be replaced with a new object for a reason that isn't automatically visible to Terraform, such as if a particular virtual machine is running on degraded underlying hardware. In this case, you can use the -replace=... planning option to force Terraform to propose replacing that object.

If the object belongs to a resource within a nested module, specify the full path to that resource including all of the nested module steps leading to it. For example:

$ terraform plan -replace=module.example.aws_instance.example

The above selects a resource "aws_instance" "example" declared inside a module "example" child module declared inside your root module.

Because replacing is a very disruptive action, Terraform only allows selecting individual resource instances. There is no syntax to force replacing all resource instances belonging to a particular module.




Modules 
	containters for multiple resources
		managed and used together
	collection of .tf/.tf.json/tfvars files 
		kept together in a directory
	main way to package and reuse
		resource configuration in Terraform
	
	
Terraform configuration 
	has atleast one module
	known as root module
	consists of resources defined in 
		.tf files 
		in main working directory.
	configurations (usually root module)
		call other modules 
		to include their resources
			into the configuration
Child module
	module called/executed by another module
	can be called multiple times
		within same configuration
	multiple configurations can use same child module
From local filesystem
	Terraform can load modules
		from a public/private registry
	can publish modules for others to use 
		can use modules published by others
	e.g. https://registry.terraform.io/modules/Azure/vnet/azurerm/latest
	
	
https://registry.terraform.io/
	There is a completely seperate doc. for modules
	There we see the documentation for accessing modules
	
lab/45

Define a Child Module
----------------------
N.B:
	Module Source (Mandatory): 
		Use Terraform Registry to begin with
	Module Version (Optional): 
		Recommended to use module version	
	
	We will use the previous example 
		remove 
			Virtual Network and 
			Subnet Terraform 
		use 
			Virtual Network Public Registry module.
	
	Refer code in 
	https://registry.terraform.io/modules/Azure/vnet/azurerm/latest
	
# Create Virtual Network and Subnets using Terraform Public Registry Module

Add below into the main.tf

module "vnet" {
  source  = "Azure/vnet/azurerm"
  version = "2.5.0"
  vnet_name = local.vnet_name
  resource_group_name = azurerm_resource_group.myrg.name
  address_space       = ["10.0.0.0/16"]
  subnet_prefixes     = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  subnet_names        = ["subnet1", "subnet2", "subnet3"]

  subnet_service_endpoints = {
    subnet2 = ["Microsoft.Storage", "Microsoft.Sql"],
    subnet3 = ["Microsoft.AzureActiveDirectory"]
  }
  tags = {
    environment = "dev"
    costcenter  = "it"
  }
  depends_on = [azurerm_resource_group.myrg]
}	
	
Modify azurerm_network_interface
	use module.vnet...
	
# Create Network Interface
resource "azurerm_network_interface" "myvmnic" {
  name                = local.nic_name
  location            = azurerm_resource_group.myrg.location
  resource_group_name = azurerm_resource_group.myrg.name

  ip_configuration {
    name                          = "internal"
    #subnet_id                     = azurerm_subnet.mysubnet.id    
    subnet_id                     = module.vnet.vnet_subnets[0]
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id = azurerm_public_ip.mypublicip.id 
  }
  tags = local.common_tags
}


Define Virtual Network Module Outputs
# Output Values - Virtual Network
output "virtual_network_name" {
  description = "Virutal Network Name"
  #value = azurerm_virtual_network.myvnet.name 
  value = module.vnet.vnet_name
}
output "virtual_network_id" {
  description = "Virutal Network ID"
  value = module.vnet.vnet_id
}
output "virtual_network_subnets" {
  description = "Virutal Network Subnets"
  value = module.vnet.vnet_subnets
}
output "virtual_network_location" {
  description = "Virutal Network Location"
  value = module.vnet.vnet_location
}
output "virtual_network_address_space" {
  description = "Virutal Network Address Space"
  value = module.vnet.vnet_address_space
}	
(no other change required)

lab/45

add ssh keys

# Terraform Init
terraform init

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-apporve

# Verify 
1) Verify in Azure Portal console , all the resources should be created.
http://<Public-IP-VM>
http://<Public-IP-VM>/app1
http://<Public-IP-VM>/app1/metadata.html

	------------------------------------------------------------------------------------------------------	
	Step-02: Create VNET Module and reference it in VMNIC Resource
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-03: Execute TF Commands, Verify VNET, Subnet and Access Sample App
	------------------------------------------------------------------------------------------------------
	covered above
	------------------------------------------------------------------------------------------------------	
	Step-04: Taint Child Module Resources and Clean-Up
	------------------------------------------------------------------------------------------------------
	
Tainting Resources in a Module
------------------------------
taint command 
	use to taint specific resources within a module
V N.B: 
	Not possible to taint an entire module. 
	Instead, 
		each resource within the module must be tainted separately.
# List Resources from State
terraform state list

# Taint a Resource
terraform taint <RESOURCE-NAME>
terraform taint module.vnet.azurerm_subnet.subnet[2]

# Terraform Plan
terraform plan
Observation: 
1. Subnet2 will be destroyed and re-created

# Terraform Apply
terraform apply -auto-approve


Clean-Up Resources & local working directory
# Terraform Destroy
terraform destroy -auto-approve

# Delete Terraform files 
rm -rf .terraform*
rm -rf terraform.tfstate*


Meta-Arguments for Modules
--------------------------
Meta-Argument concepts 
	same as how we learned during Resources section.

		count
		for_each
		providers
		depends_on
		lifecycle

Meta arguments		
	https://www.terraform.io/docs/language/modules/syntax.html#meta-arguments
	
Module sources	
	https://www.terraform.io/docs/language/modules/sources.html
	------------------------------------------------------------------------------------------------------	
	Step-01: Understand about Child Modules and Create it
	------------------------------------------------------------------------------------------------------

lab/46
50

End Goal: 
	Build a Terraform Local Module

Create a Terraform module
Use local Terraform modules in your configuration
Configure modules with variables
Use module outputs
We are going to write a local re-usable module for the following usecase.
Usecase: Hosting a static website using Azure Storage Account
Create a Azure Storage Account
Enable Static webstite option
Upload Static Content and test
For steps, 1 and 2 we are going to create a re-usable module in Terraform
How are we going to do this?
We are going to do this in 3 sections
Section-1 - Full Manual: Create Static Website on Azure Storage Account using Azure Portal Management Console and host static content and test
Section-2 - Terraform Resources: Automate section-1 using Terraform Resources
Section-3 - Terraform Modules: Create a re-usable module for hosting static website by referencing section-2 terraform configuration files.



	------------------------------------------------------------------------------------------------------	
	Step-02: Create Root Module TF Configs
	------------------------------------------------------------------------------------------------------

	------------------------------------------------------------------------------------------------------	
	Step-03: Execute TF Commands, Verify and CleanUp Static Website created
	------------------------------------------------------------------------------------------------------


Hosting a Static Website with Azure Storage Account
lab/48
50
Step1
Create Azure Storage Account
	Login to Azure Portal Console
	Go to Storage Accounts -> Create
	Resource Group: myrg-sw-1
	Storage account name: <name>staticwebsitek123 (Should be unique across Azure)
	Region: East US
	Performance: Standard
	Redundancy: LRS
	Rest all leave to defaults
	Click on Review + Create
	Click on Create

Step 2
Enable Static Website
	Goto Storage Account -> staticwebsitek123 -> Data Management -> Static Website
	Click on Enabled
	Index document name: index.html
	Error document path: error.html

Step 3: Upload Static Content
Goto Storage Account -> <name>staticwebsite -> Data Storage -> Containers -> $web
Upload Static files from static-content folder
	index.html
	error.html

Step 4: Access Static Website
Goto Storage Account -> <name>staticwebsite -> Data Management -> Static Website
	Get the endpoint name Primary endpoint
	# Primary Endpoint
	https://<name>staticwebsite.z13.web.core.windows.net/

Conclusion
We have used multiple manual steps to host a static website on Azure Storage Account
Now all the above manual steps automate using Terraform in next step


Do the same using Terraform
----------------------------

Create Terraform Configuration to Host a Static Website on Azure

We are going to host a static website on Azure Storage Account using general terraform configuration files

Below will be the naming convention for Terraform Configs
	provider.tf
	main.tf
	variables.tf
	outputs.tf
	terraform.tfvars



# Terraform Initialize
terraform init

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve

# Upload Static Content
1. Go to Storage Accounts -> <name>staticwebsite -> Containers -> $web
2. Upload files from folder "static-content"

# Verify 
1. Azure Storage Account created
2. Static Website Setting enabled
3. Verify the Static Content Upload Successful
4. Access Static Website: Goto Storage Account -> <name>staticwebsitek -> Data Management -> Static Website
5. Get the endpoint name `Primary endpoint`
https://<name>staticwebsitek.z13.web.core.windows.net/



# Terraform Destroy
terraform destroy -auto-approve

# Delete Terraform files 
rm -rf .terraform*
rm -rf terraform.tfstate*
	------------------------------------------------------------------------------------------------------	
	Step-04: Understand Terraform get command
	------------------------------------------------------------------------------------------------------

	terraform init 
		download 
			providers 
				[from terraform registry] 
			modules present in local modules folder 
				in terraform working directory.
	we initialized using 
		terraform init and 
		created module configs
			we can 
				"terraform get" 
					to download the same.
	
	When we add new 
		module to a configuration
	Terraform must install the module before it can be used.

terraform get and terraform init commands 
	will install and 
	update modules.
The terraform init command 
	initialize backends and 
	install plugins.
# Delete modules in .terraform folder
ls -lrt .terraform/modules
rm -rf .terraform/modules
ls -lrt .terraform/modules

# Terraform Get
terraform get
ls -lrt .terraform/modules



Introduction
	We will build 
		Terraform local module 
			to host a static website 
			on Azure Storage Account.
		understand how to call 
			Local Re-usable module 
				in to a Root Module.
		how the local module variables becomes the arguments inside a module block when it is called in Root Module c3-static-webiste.tf
	We will understand how we define the output values for a local module in a Root module c4-outputs.tf

Terraform Comamnd terraform get
-------------------------------
differences between 
	terraform init and 
	terraform get

Step 2: Create Module Folder Structure
Aim:
	create modules folder 
	create a module named 
		azure-static-website
	copy required files from previous section for this respective module 	
	terraform-manifests.
		48/*
Terraform Working Directory: 
	49/*
		modules
		Module-1: azure-static-website
		main.tf
		variables.tf
		outputs.tf
		README.md
		LICENSE
Inside modules/azure-static-website, 
	copy following files from 48
		main.tf
		variables.tf
		outputs.tf
		versions.tf

Step 3: Root Module: 
	provider.tf
Call Module from Terraform Work Directory
Create Terraform Configuration in Root Module 
	by calling the newly created module
		c1-versions.tf
		c2-variables.tf
		c3-static-website.tf
		c4-outputs.tf

# Terraform Block
terraform {
  required_version = ">= 1.0.0"
  required_providers {
    azurerm = {
      source = "hashicorp/azurerm"
      version = ">= 2.0" 
    }    
  }
}

# Provider Block
provider "azurerm" {
 features {}          
}

Step-04: c2-variables.tf
Place holder file, if you want you can define variables.
For now focus is on Calling the Local Terraform Module in to Root Module so we are not going to complicate the stuff here.
We will leave this placeholder file
Step-05: c3-static-website.tf
Arguments for this module are going to be the variables defined in variables.tf of local module
# Call our Custom Terraform Module which we built earlier
module "azure_static_website" {
  source = "./modules/azure-static-website"  # Mandatory

  # Resource Group
  location = "eastus"
  resource_group_name = "myrg1"

  # Storage Account
  storage_account_name = "staticwebsite"
  storage_account_tier = "Standard"
  storage_account_replication_type = "LRS"
  storage_account_kind = "StorageV2"
  static_website_index_document = "index.html"
  static_website_error_404_document = "error.html"
}
Step-06: c4-outputs.tf
Understand how we are going to reference the output values from a local module
The output names defined in local module outputs.tf will be the values in this c4-outputs.tf
# Output variable definitions
output "root_resource_group_id" {
  description = "resource group id"
  value       = module.azure_static_website.resource_group_id
}
output "root_resource_group_name" {
  description = "The name of the resource group"
  value       = module.azure_static_website.resource_group_name
}
output "root_resource_group_location" {
  description = "resource group location"
  value       = module.azure_static_website.resource_group_location
}
output "root_storage_account_id" {
  description = "storage account id"
  value       = module.azure_static_website.storage_account_id
}
output "root_storage_account_name" {
  description = "storage account name"
  value       = module.azure_static_website.storage_account_name
}
Step-07: Execute Terraform Commands
# Terraform Initialize
terraform init
Observation: 
1. Verify ".terraform", you will find "modules" folder in addition to "providers" folder
2. Verify inside ".terraform/modules" folder too.

# Terraform Validate
terraform validate

# Terraform Format
terraform fmt

# Terraform Plan
terraform plan

# Terraform Apply
terraform apply -auto-approve

# Upload Static Content
1. Go to Storage Accounts -> staticwebsitexxxxxx -> Containers -> $web
2. Upload files from folder "static-content"

# Verify 
1. Azure Storage Account created
2. Static Website Setting enabled
3. Verify the Static Content Upload Successful
4. Access Static Website: Goto Storage Account -> staticwebsitek123 -> Data Management -> Static Website
5. Get the endpoint name `Primary endpoint`
https://staticwebsitek123.z13.web.core.windows.net/
Step-08: Destroy and Clean-Up
# Terraform Destroy
terraform destroy -auto-approve

# Delete Terraform files 
rm -rf .terraform*
rm -rf terraform.tfstate*
Step-09: Understand terraform get command
We have used terraform init to download providers from terraform registry and at the same time to download modules present in local modules folder in terraform working directory.
Assuming we already have initialized using terraform init and later we have created module configs, we can terraform get to download the same.
Whenever you add a new module to a configuration, Terraform must install the module before it can be used.
Both the terraform get and terraform init commands will install and update modules.
The terraform init command will also initialize backends and install plugins.
# Delete modules in .terraform folder
ls -lrt .terraform/modules
rm -rf .terraform/modules
ls -lrt .terraform/modules

# Terraform Get
terraform get
ls -lrt .terraform/modules


51 end	------------------------------------------------------------------------------------------------------	
	Step-01: Create Git Repo and Commit Static Website TF Module Files and Create 1.
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-02: Publish the Module to Terraform Public Registry and Verify
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-03: Create Root Module and call public registry module newly published
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-04: Learn Module Management in Public Registry and Module Versioning
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-01: Introduction to Terraform Private Module Registry
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-02: Create Git Repo and Publish 1.0.0 release
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-03: Create Github Oauth Connection and Publish Private Module in TF Cloud
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Step-04: Create TF Configs, Use Source as Private Module and Execute TF Commands
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	

Day 5
------------------------------------------------------------------------------------------------------
Packer
------------------------------------------------------------------------------------------------------
	Build automated machine images for multiple platforms from a single configuration file
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Create images in parallel
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Use tools like Chef or Puppet to do the provisioning
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Use it along with Continuous delivery tools
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Launch the instance using the image, test and verify the infrastructure along with the development
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Learn about variables and other details of the HCL file
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Learn various provisions and builders
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Understand the difference between Ansible local and remote builder
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Create a docker container image, shell local and remote builder
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Create windows AMI
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Create and test Vagrant images
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Work with post-processors and other components of Hashicorp Packer
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Code Organization with Packer
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Packer Variables, Provisioners, Post-Processors
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
	Integrations with HashiCorp and DevOps
	------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------	
------------------------------------------------------------------------------------------------------	


Additional reference:
	https://github.com/hashicorp/learn-terraform-apply
	https://learn.hashicorp.com/tutorials/terraform/apply?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS

Terraform drift management
	https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform
	
Oracle public cloud	
	https://registry.terraform.io/providers/oracle/oci/latest/docs	
oci instance	
	https://registry.terraform.io/providers/oracle/oci/latest/docs/resources/core_instance	
	
	